{"version":3,"file":"replay.min.js","sources":["../src/replay.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * @module     tiny_cursive/replay\n * @category TinyMCE Editor\n * @copyright  CTI <info@cursivetechnology.com>\n * @author kuldeep singh <mca.kuldeep.sekhon@gmail.com>\n */\n\nimport {call as fetchJson} from 'core/ajax';\nimport templates from 'core/templates';\nimport $ from 'jquery';\nimport * as Str from 'core/str';\n\nexport default class Replay {\n    controllerId = '';\n\n    constructor(elementId, filePath, speed = 1, loop = false, controllerId) {\n        this.controllerId = controllerId;\n        this.replayInProgress = false;\n        this.speed = parseFloat(speed);\n        this.loop = loop;\n        this.highlightedChars = [];\n        this.deletedChars = [];\n        this.cursorPosition = 0;\n        this.currentEventIndex = 0;\n        this.totalEvents = 0;\n        this.currentTime = 0;\n        this.totalDuration = 0;\n        this.usercomments = [];\n        this.pasteTimestamps = [];\n        this.isPasteEvent = false;\n\n        const element = document.getElementById(elementId);\n        if (element) {\n            this.outputElement = element;\n        } else {\n            throw new Error(`Element with id '${elementId}' not found`);\n        }\n\n        this.loadJSON(filePath)\n            .then((data) => {\n                if (data.status) {\n                    var val = JSON.parse(data.data);\n                    this.logData = val;\n                    if (data.comments) {\n                        var comments = JSON.parse(data.comments);\n                        this.usercomments = Array.isArray(comments) ? [...comments] : [];\n                    }\n\n                    if (\"data\" in this.logData) {\n                        this.logData = this.logData.data;\n                    }\n                    if (\"payload\" in this.logData) {\n                        this.logData = this.logData.payload;\n                    }\n\n                    if (this.logData.length > 0 && this.logData[0].unixTimestamp) {\n                        const startTime = this.logData[0].unixTimestamp;\n                        this.logData = this.logData.map(event => ({\n                            ...event,\n                            normalizedTime: event.unixTimestamp - startTime\n                        }));\n                        this.totalDuration = this.logData[this.logData.length - 1].normalizedTime;\n                    }\n\n                    this.totalEvents = this.logData.length;\n                    this.identifyPasteEvents();\n                    if (controllerId && this.logData) {\n                        this.constructController(controllerId);\n                    }\n                    this.startReplay();\n                } else {\n                    try {\n                        // eslint-disable-next-line\n                        Promise.all([\n                            templates.render('tiny_cursive/no_submission'),\n                            Str.get_string('warningpayload', 'tiny_cursive')\n                        ])\n                            .then(function(results) {\n                                var html = results[0];\n                                var str = results[1];\n                                var newElement = $(html);\n                                newElement.text(str);\n                                $('.tiny_cursive').html(newElement);\n                                return true;\n                            })\n                            .catch(function(error) {\n                                window.console.error(error);\n                            });\n                    } catch (error) {\n                        window.console.error(error);\n                    }\n                }\n                return data;\n            })\n            .catch(error => {\n                try {\n                    // eslint-disable-next-line\n                    Promise.all([\n                        templates.render('tiny_cursive/no_submission'),\n                        Str.get_string('warningpayload', 'tiny_cursive')\n                    ])\n                        .then(function(results) {\n                            var html = results[0];\n                            var str = results[1];\n                            var newElement = $(html);\n                            newElement.text(str);\n                            return $('.tiny_cursive').html(newElement);\n                        })\n                        .catch(function(error) {\n                            window.console.error(error);\n                        });\n                } catch (error) {\n                    window.console.error(error);\n                }\n                window.console.error('Error loading JSON file: ' + error.message);\n            });\n    }\n\n    stopReplay() {\n        if (this.replayInProgress) {\n            clearTimeout(this.replayTimeout);\n            this.replayInProgress = false;\n            var playSvg = document.createElement('img');\n            playSvg.src = M.util.image_url('playicon', 'tiny_cursive');\n\n            if (this.playButton) {\n                this.playButton.querySelector('.play-icon').innerHTML = playSvg.outerHTML;\n            }\n        }\n    }\n\n    constructController(controllerId) {\n        this.replayInProgress = false;\n        this.currentPosition = 0;\n        this.speed = 1;\n        if (this.replayIntervalId) {\n            clearInterval(this.replayIntervalId);\n            this.replayIntervalId = null;\n        }\n\n        const container = document.getElementById(controllerId);\n        if (!container) {\n            window.console.error(\"Container not found with ID:\", controllerId);\n            return;\n        }\n\n        const controlContainer = container.querySelector('.tiny_cursive_replay_control');\n        if (!controlContainer) {\n            window.console.error(\"Replay control container not found in:\", controllerId);\n            return;\n        }\n        controlContainer.innerHTML = '<span class=\"tiny_cursive_loading_spinner\"></span>';\n\n        const topRow = document.createElement('div');\n        topRow.classList.add('tiny_cursive_top_row');\n\n        // Play button\n        this.playButton = document.createElement('button');\n        this.playButton.classList.add('tiny_cursive_play_button');\n        const playSvg = document.createElement('i');\n        playSvg.className = '';\n        this.playButton.innerHTML = `<span class=\"play-icon\">${playSvg.outerHTML}</span>`;\n\n        this.playButton.addEventListener('click', () => {\n            if (this.replayInProgress) {\n                this.stopReplay();\n                const playImg = document.createElement('img');\n                playImg.src = M.util.image_url('playicon', 'tiny_cursive');\n                this.playButton.querySelector('.play-icon').innerHTML = playImg.outerHTML;\n            } else {\n                this.startReplay(false);\n            }\n            $('.tiny_cursive-nav-tab').find('.active').removeClass('active');\n            $('a[id^=\"rep\"]').addClass('active');\n        });\n        topRow.appendChild(this.playButton);\n\n        // Scrubber\n        const scrubberContainer = document.createElement('div');\n        scrubberContainer.classList.add('tiny_cursive_scrubber_container');\n\n        this.scrubberElement = document.createElement('input');\n        this.scrubberElement.classList.add('tiny_cursive_timeline_scrubber', 'timeline-scrubber');\n        this.scrubberElement.type = 'range';\n        this.scrubberElement.max = '100';\n        this.scrubberElement.min = '0';\n        this.scrubberElement.value = '0';\n\n        this.scrubberElement.addEventListener('input', () => {\n            const scrubberValue = parseInt(this.scrubberElement.value, 10);\n            this.skipToTime(scrubberValue);\n        });\n\n        scrubberContainer.appendChild(this.scrubberElement);\n        topRow.appendChild(scrubberContainer);\n\n        // Time display\n        this.timeDisplay = document.createElement('div');\n        this.timeDisplay.classList.add('tiny_cursive_time_display');\n        this.timeDisplay.textContent = '00:00 / 00:00';\n        topRow.appendChild(this.timeDisplay);\n\n        const bottomRow = document.createElement('div');\n        bottomRow.classList.add('tiny_cursive_bottom_row');\n\n        // Speed controls\n        const speedContainer = document.createElement('div');\n        speedContainer.classList.add('tiny_cursive_speed_controls', 'speed-controls');\n\n        const speedLabel = document.createElement('span');\n        speedLabel.classList.add('tiny_cursive_speed_label');\n        speedLabel.textContent = 'Speed: ';\n        speedContainer.appendChild(speedLabel);\n\n        const speedGroup = document.createElement('div');\n        speedGroup.classList.add('tiny_cursive_speed_group');\n\n        [1, 1.5, 2, 5, 10].forEach(speedValue => {\n            const speedBtn = document.createElement('button');\n            speedBtn.textContent = `${speedValue}x`;\n            speedBtn.classList.add('tiny_cursive_speed_btn', 'speed-btn');\n            if (parseFloat(speedValue) === parseFloat(this.speed)) {\n                speedBtn.classList.add('active');\n            }\n            speedBtn.dataset.speed = speedValue;\n\n            speedBtn.addEventListener('click', () => {\n                document.querySelectorAll('.tiny_cursive_speed_btn').forEach(btn => btn.classList.remove('active'));\n                speedBtn.classList.add('active');\n                this.speed = parseFloat(speedBtn.dataset.speed);\n                if (this.replayInProgress) {\n                    this.stopReplay();\n                    this.startReplay(false);\n                }\n            });\n\n            speedGroup.appendChild(speedBtn);\n        });\n\n        speedContainer.appendChild(speedGroup);\n        bottomRow.appendChild(speedContainer);\n\n        const existingPanel = container.querySelector('.paste-events-panel');\n        if (existingPanel) {\n            existingPanel.remove();\n        }\n\n        // Paste Events Toggle\n        const pasteEventsToggle = document.createElement('div');\n        pasteEventsToggle.classList.add('tiny_cursive_paste_events_toggle', 'paste-events-toggle');\n\n        const pasteEventsIcon = document.createElement('span');\n        const pasteIcon = document.createElement('img');\n        pasteIcon.src = M.util.image_url('pasteicon', 'tiny_cursive');\n        pasteEventsIcon.innerHTML = pasteIcon.outerHTML;\n        pasteEventsIcon.classList.add('tiny_cursive_paste_events_icon');\n\n        const pasteEventsText = document.createElement('span');\n        pasteEventsText.textContent = 'Paste Events';\n\n        const pasteEventCount = document.createElement('span');\n        pasteEventCount.textContent = `(${this.usercomments.length})`;\n        pasteEventCount.className = 'paste-event-count';\n        pasteEventCount.style.marginLeft = '2px';\n\n        const chevronIcon = document.createElement('span');\n        const chevron = document.createElement('i');\n        chevron.className = 'fa fa-chevron-down';\n        chevronIcon.innerHTML = chevron.outerHTML;\n        chevronIcon.style.marginLeft = '5px';\n        chevronIcon.style.transition = 'transform 0.3s ease';\n\n        pasteEventsToggle.appendChild(pasteEventsIcon);\n        pasteEventsToggle.appendChild(pasteEventsText);\n        pasteEventsToggle.appendChild(pasteEventCount);\n        pasteEventsToggle.appendChild(chevronIcon);\n\n        // Create Paste Events Panel\n        const pasteEventsPanel = document.createElement('div');\n        pasteEventsPanel.classList.add('tiny_cursive_paste_events_panel', 'paste-events-panel');\n        pasteEventsPanel.style.display = 'none';\n\n        this.populatePasteEventsPanel(pasteEventsPanel);\n\n        pasteEventsToggle.addEventListener('click', () => {\n            const isHidden = pasteEventsPanel.style.display === 'none';\n            pasteEventsPanel.style.display = isHidden ? 'block' : 'none';\n            chevronIcon.style.transform = isHidden ? 'rotate(180deg)' : 'rotate(0)';\n        });\n\n        bottomRow.appendChild(pasteEventsToggle);\n\n        this.pasteEventsPanel = pasteEventsPanel;\n        this.pasteEventCount = pasteEventCount;\n\n        controlContainer.appendChild(topRow);\n        controlContainer.appendChild(bottomRow);\n        container.appendChild(pasteEventsPanel);\n\n        controlContainer.querySelector('.tiny_cursive_loading_spinner')?.remove();\n    }\n\n    identifyPasteEvents() {\n        this.pasteTimestamps = [];\n        let controlPressed = false;\n        let pasteCount = 0;\n\n        // Check for finding Control+V combinations\n        for (let i = 0; i < this.logData.length; i++) {\n            const event = this.logData[i];\n            if (event.event && event.event.toLowerCase() === \"keydown\") {\n                if (event.key === \"Control\") {\n                    controlPressed = true;\n                } else if (event.key === \"v\" && controlPressed) {\n                    const timestamp = event.normalizedTime || 0;\n\n                    let userComment = \"\";\n                    if (this.usercomments && this.usercomments[pasteCount]) {\n                        userComment = this.usercomments[pasteCount];\n                    }\n\n                    this.pasteTimestamps.push({\n                        index: pasteCount,\n                        time: timestamp,\n                        formattedTime: this.formatTime(timestamp),\n                        pastedText: userComment,\n                        timestamp: timestamp\n                    });\n                    pasteCount++;\n\n                    controlPressed = false;\n                } else {\n                    controlPressed = false;\n                }\n            }\n        }\n\n        if (this.usercomments.length > 0 && this.pasteTimestamps.length === 0) {\n            for (let i = 0; i < this.usercomments.length; i++) {\n                this.pasteTimestamps.push({\n                    index: i,\n                    time: 0,\n                    formattedTime: this.formatTime(0),\n                    pastedText: this.usercomments[i],\n                    timestamp: 0\n                });\n            }\n        }\n\n        while (this.pasteTimestamps.length < this.usercomments.length) {\n            const lastIndex = this.pasteTimestamps.length;\n            this.pasteTimestamps.push({\n                index: lastIndex,\n                time: 0,\n                formattedTime: this.formatTime(0),\n                pastedText: this.usercomments[lastIndex],\n                timestamp: 0\n            });\n        }\n\n        if (this.pasteEventsPanel) {\n            this.populatePasteEventsPanel(this.pasteEventsPanel);\n        }\n    }\n\n    populatePasteEventsPanel(panel) {\n        panel.innerHTML = '';\n\n        while (panel.firstChild) {\n            panel.removeChild(panel.firstChild);\n        }\n        panel.classList.add('tiny_cursive_event_panel');\n\n        const pasteEvents = this.pasteTimestamps && this.pasteTimestamps.length ?\n            this.pasteTimestamps : [];\n\n        if (!pasteEvents || pasteEvents.length === 0) {\n            const noEventsMessage = document.createElement('div');\n            noEventsMessage.className = 'no-paste-events-message p-3';\n            noEventsMessage.textContent = 'No paste events detected for this submission.';\n            panel.appendChild(noEventsMessage);\n            return;\n        }\n\n        const carouselContainer = document.createElement('div');\n        carouselContainer.classList.add('tiny_cursive_paste_events_carousel', 'paste-events-carousel');\n\n        const navigationRow = document.createElement('div');\n        navigationRow.classList.add('paste-events-navigation', 'tiny_cursive_navigation_row');\n\n        const counterDisplay = document.createElement('div');\n        counterDisplay.classList.add('paste-events-counter', 'tiny_cursive_counter_display');\n        counterDisplay.textContent = 'Paste Events';\n\n        const navButtons = document.createElement('div');\n        navButtons.classList.add('tiny_cursive_nav_buttons', 'tiny_cursive_nav_buttons');\n\n        const prevButton = document.createElement('button');\n        prevButton.classList.add('paste-event-prev-btn', 'tiny_cursive_nav_button');\n        const leftChevron = document.createElement('i');\n        leftChevron.className = 'fa fa-chevron-left';\n        prevButton.innerHTML = leftChevron.outerHTML;\n\n        const nextButton = document.createElement('button');\n        nextButton.className = 'paste-event-next-btn tiny_cursive_nav_button';\n        const rightChevron = document.createElement('i');\n        rightChevron.className = 'fa fa-chevron-right';\n        nextButton.innerHTML = rightChevron.outerHTML;\n        nextButton.disabled = pasteEvents.length <= 1;\n\n        navButtons.appendChild(prevButton);\n        navButtons.appendChild(nextButton);\n\n        navigationRow.appendChild(counterDisplay);\n        navigationRow.appendChild(navButtons);\n\n        const contentContainer = document.createElement('div');\n        contentContainer.className = 'paste-events-content tiny_cursive_content_container';\n\n        // Create initial content with first paste event\n        const createPasteEventDisplay = (pasteEvent) => {\n            const eventRow = document.createElement('div');\n            eventRow.className = 'tiny_cursive_event_row';\n\n            // Header row with timestamp and play button\n            const headerRow = document.createElement('div');\n            headerRow.className = 'tiny_cursive_header_row';\n\n            // Timestamp and text container\n            const textContainer = document.createElement('div');\n            textContainer.className = 'tiny_cursive_text_container';\n\n            const timestampContainer = document.createElement('div');\n            timestampContainer.className = 'paste-event-timestamp tiny_cursive_paste_event_timestamp';\n            timestampContainer.textContent = pasteEvent.formattedTime;\n\n            const pastedTextContainer = document.createElement('div');\n            pastedTextContainer.className = 'paste-event-text tiny_cursive_pasted_text_container';\n            pastedTextContainer.textContent = pasteEvent.pastedText;\n\n            textContainer.appendChild(timestampContainer);\n            textContainer.appendChild(pastedTextContainer);\n\n            const playButton = document.createElement('button');\n            playButton.className = 'paste-event-play-btn tiny_cursive_seekplay_button';\n\n            const playIcon = document.createElement('img');\n            playIcon.src = M.util.image_url('seekplayicon', 'tiny_cursive');\n            playButton.innerHTML = playIcon.outerHTML;\n\n            playButton.addEventListener('click', () => {\n                this.jumpToTimestamp(pasteEvent.timestamp);\n            });\n\n            headerRow.appendChild(textContainer);\n            headerRow.appendChild(playButton);\n\n            eventRow.appendChild(headerRow);\n\n            return eventRow;\n        };\n\n        contentContainer.appendChild(createPasteEventDisplay(pasteEvents[0]));\n\n        carouselContainer.appendChild(navigationRow);\n        carouselContainer.appendChild(contentContainer);\n\n        panel.appendChild(carouselContainer);\n\n        let currentIndex = 0;\n\n        prevButton.addEventListener('click', () => {\n            if (currentIndex > 0) {\n                currentIndex--;\n                updatePasteEventDisplay();\n            }\n        });\n\n        nextButton.addEventListener('click', () => {\n            if (currentIndex < pasteEvents.length - 1) {\n                currentIndex++;\n                updatePasteEventDisplay();\n            }\n        });\n\n        const updatePasteEventDisplay = () => {\n            contentContainer.innerHTML = '';\n            contentContainer.appendChild(createPasteEventDisplay(pasteEvents[currentIndex]));\n\n            counterDisplay.textContent = 'Paste Events';\n\n            prevButton.disabled = currentIndex === 0;\n            prevButton.style.opacity = currentIndex === 0 ? '0.5' : '1';\n            nextButton.disabled = currentIndex === pasteEvents.length - 1;\n            nextButton.style.opacity = currentIndex === pasteEvents.length - 1 ? '0.5' : '1';\n        };\n    }\n\n    jumpToTimestamp(timestamp) {\n        const percentage = this.totalDuration > 0 ? (timestamp / this.totalDuration) * 100 : 0;\n\n        this.skipToTime(percentage);\n\n        if (!this.replayInProgress) {\n            this.startReplay(false);\n        }\n    }\n\n\n    setScrubberVal(value) {\n        if (this.scrubberElement) {\n            this.scrubberElement.value = String(value);\n\n            if (this.timeDisplay) {\n                const displayTime = Math.min(this.currentTime, this.totalDuration);\n                const currentTimeFormatted = this.formatTime(displayTime);\n                const totalTimeFormatted = this.formatTime(this.totalDuration);\n                this.timeDisplay.textContent = `${currentTimeFormatted} / ${totalTimeFormatted}`;\n            }\n        }\n    }\n\n    loadJSON(filePath) {\n        return fetchJson([{\n            methodname: 'cursive_get_reply_json',\n            args: {\n                filepath: filePath,\n            },\n        }])[0].done(response => {\n            return response;\n        }).fail(error => {\n            throw new Error('Error loading JSON file: ' + error.message);\n        });\n    }\n\n    formatTime(ms) {\n        const seconds = Math.floor(ms / 1000);\n        const minutes = Math.floor(seconds / 60);\n        const remainingSeconds = seconds % 60;\n        return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;\n    }\n\n    // Call this to make a \"start\" or \"start over\" function\n    startReplay(reset = true) {\n        // Clear previous instances of timeout to prevent multiple running at once\n        if (this.replayInProgress) {\n            clearTimeout(this.replayTimeout);\n        }\n        const atEnd = (this.totalDuration > 0 && this.currentTime >= this.totalDuration) ||\n            (this.currentEventIndex >= this.totalEvents);\n        if (atEnd && !reset) {\n            reset = true;\n        }\n        this.replayInProgress = true;\n        if (reset) {\n            this.outputElement.innerHTML = '';\n            this.text = '';\n            this.cursorPosition = 0;\n            this.currentEventIndex = 0;\n            this.currentTime = 0;\n            this.highlightedChars = [];\n            this.deletedChars = [];\n            this.isControlKeyPressed = false;\n        }\n        if (this.playButton) {\n            const pauseSvg = document.createElement('i');\n            pauseSvg.className = 'fa fa-pause';\n            this.playButton.querySelector('.play-icon').innerHTML = pauseSvg.outerHTML;\n        }\n        this.replayLog();\n    }\n\n    // Called by startReplay() to recursively call through keydown events\n    // Refactored replayLog and helpers\n    replayLog() {\n        if (!this.replayInProgress) {\n            this.updateDisplayText(this.text, this.cursorPosition, [], []);\n            return;\n        }\n\n        while (this.currentEventIndex < this.logData.length) {\n            const event = this.logData[this.currentEventIndex];\n            if (event.normalizedTime && event.normalizedTime > this.currentTime) {\n                break;\n            }\n\n            const {updatedText, updatedCursor, updatedHighlights, updatedDeleted} =\n                this.processEvent(event, this.text, this.cursorPosition, this.highlightedChars, this.deletedChars);\n\n            this.text = updatedText;\n            this.cursorPosition = updatedCursor;\n            this.highlightedChars = updatedHighlights;\n            this.deletedChars = updatedDeleted;\n\n            this.currentEventIndex++;\n        }\n\n        this.updateDisplayText(this.text, this.cursorPosition, this.highlightedChars, this.deletedChars);\n        this.updateReplayStatus();\n    }\n\n    processEvent(event, text, cursor, highlights, deletions) {\n        let updatedHighlights = [...highlights];\n        let updatedDeleted = [...deletions];\n\n        if (event.rePosition !== undefined && (this.currentEventIndex === 0\n            || event.event === 'mouseDown' || event.event === 'mouseUp')) {\n            cursor = Math.max(0, Math.min(event.rePosition, text.length));\n        }\n\n        if (event.event?.toLowerCase() === \"keydown\") {\n            ({text, cursor, updatedHighlights, updatedDeleted} =\n                this.handleKeydown(event, text, cursor, updatedHighlights, updatedDeleted));\n        }\n\n        updatedHighlights = updatedHighlights.filter(h => !h.expiresAt || h.expiresAt > this.currentTime);\n        updatedDeleted = updatedDeleted.filter(d => !d.expiresAt || d.expiresAt > this.currentTime);\n\n        return {updatedText: text, updatedCursor: cursor, updatedHighlights, updatedDeleted};\n    }\n\n    handleKeydown(event, text, cursor, highlights, deletions) {\n        const key = event.key;\n        const charToInsert = this.applyKey(key);\n\n        // Update Control and Paste states\n        if (key === \"Control\") {\n            this.isControlKeyPressed = true;\n        } else if (key === \"v\" && this.isControlKeyPressed) {\n            this.isPasteEvent = true;\n            this.isControlKeyPressed = false;\n        } else if (key !== \"v\") {\n            this.isControlKeyPressed = false;\n        }\n\n        // Helper to update highlights when inserting a char\n        const insertChar = (char) => {\n            text = text.slice(0, cursor) + char + text.slice(cursor);\n            if (char.trim()) {\n                highlights.push({\n                    index: cursor,\n                    \"char\": char,\n                    time: this.currentTime,\n                    expiresAt: this.currentTime + 1500\n                });\n            }\n            cursor++;\n        };\n\n        if (this.isControlKeyPressed) {\n            switch (key) {\n                case \"Backspace\":\n                    ({text, cursor, deletions} = this.handleCtrlBackspace(text, cursor, deletions));\n                    this.isControlKeyPressed = false;\n                    break;\n                case \"Delete\":\n                    ({text, deletions} = this.handleCtrlDelete(text, cursor, deletions));\n                    this.isControlKeyPressed = false;\n                    break;\n                case \"ArrowLeft\":\n                    cursor = this.findPreviousWordBoundary(text, cursor);\n                    break;\n                case \"ArrowRight\":\n                    cursor = this.findNextWordBoundary(text, cursor);\n                    break;\n                default:\n                    break;\n            }\n        } else {\n            switch (key) {\n                case \"Backspace\":\n                    if (!this.isPasteEvent) {\n                        ({text, cursor, deletions} = this.handleBackspace(text, cursor, deletions));\n                    }\n                    break;\n                case \"Delete\":\n                    ({text, deletions} = this.handleDelete(text, cursor, deletions));\n                    break;\n                case \"ArrowLeft\":\n                    cursor = Math.max(0, cursor - 1);\n                    break;\n                case \"ArrowRight\":\n                    cursor = Math.min(text.length, cursor + 1);\n                    break;\n                default:\n                    if (charToInsert) {\n                        insertChar(charToInsert);\n                    }\n                    break;\n            }\n        }\n\n        return {text, cursor, updatedHighlights: highlights, updatedDeleted: deletions};\n    }\n\n    handleCtrlBackspace(text, cursor, deletions) {\n        if (cursor === 0) {\n            return {text, cursor, deletions};\n        }\n\n        let wordStart = cursor;\n        while (wordStart > 0 && text[wordStart - 1] === ' ') {\n            wordStart--;\n        }\n        while (wordStart > 0 && text[wordStart - 1] !== ' ') {\n            wordStart--;\n        }\n\n        const word = text.slice(wordStart, cursor);\n        for (let i = 0; i < word.length; i++) {\n            deletions.push({\n                index: wordStart + i,\n                \"char\": word[i],\n                time: this.currentTime,\n                expiresAt: this.currentTime + 2000\n            });\n        }\n        return {\n            text: text.slice(0, wordStart) + text.slice(cursor),\n            cursor: wordStart,\n            deletions\n        };\n    }\n\n    handleCtrlDelete(text, cursor, deletions) {\n        const wordEnd = this.findNextWordBoundary(text, cursor);\n        const word = text.slice(cursor, wordEnd);\n        for (let i = 0; i < word.length; i++) {\n            deletions.push({\n                index: cursor + i,\n                \"char\": word[i],\n                time: this.currentTime,\n                expiresAt: this.currentTime + 2000\n            });\n        }\n        return {text: text.slice(0, cursor) + text.slice(wordEnd), deletions};\n    }\n\n    handleBackspace(text, cursor, deletions) {\n        if (cursor === 0) {\n            return {text, cursor, deletions};\n        }\n        deletions.push({\n            index: cursor - 1,\n            \"char\": text[cursor - 1],\n            time: this.currentTime,\n            expiresAt: this.currentTime + 2000\n        });\n        return {\n            text: text.slice(0, cursor - 1) + text.slice(cursor),\n            cursor: cursor - 1,\n            deletions\n        };\n    }\n\n    handleDelete(text, cursor, deletions) {\n        if (cursor >= text.length) {\n            return {text, deletions};\n        }\n        deletions.push({\n            index: cursor,\n            \"char\": text[cursor],\n            time: this.currentTime,\n            expiresAt: this.currentTime + 2000\n        });\n        return {\n            text: text.slice(0, cursor) + text.slice(cursor + 1),\n            deletions\n        };\n    }\n\n    updateReplayStatus() {\n        if (this.totalDuration > 0) {\n            const percentComplete = Math.min((this.currentTime / this.totalDuration) * 100, 100);\n            this.setScrubberVal(percentComplete);\n        }\n\n        if (this.replayInProgress) {\n            const baseIncrement = 100;\n            const incrementTime = baseIncrement / this.speed;\n            this.currentTime += baseIncrement;\n\n            if (this.currentEventIndex >= this.totalEvents) {\n                if (this.loop) {\n                    this.startReplay(true);\n                } else {\n                    this.stopReplay();\n                    this.updateDisplayText(this.text, this.cursorPosition, [], []);\n                }\n            } else {\n                this.replayTimeout = setTimeout(() => this.replayLog(), incrementTime);\n            }\n        }\n    }\n\n    findNextWordBoundary(text, cursor) {\n        if (!text || cursor >= text.length) {\n            return cursor;\n        }\n\n        if (text[cursor] === ' ') {\n            while (cursor < text.length && text[cursor] === ' ') {\n                cursor++;\n            }\n        }\n\n        if (cursor >= text.length) {\n            let lastNonSpace = text.length - 1;\n            while (lastNonSpace >= 0 && text[lastNonSpace] === ' ') {\n                lastNonSpace--;\n            }\n            cursor = lastNonSpace + 1;\n            return cursor;\n        }\n\n        let wordEnd = cursor;\n        while (wordEnd < text.length && text[wordEnd] !== ' ') {\n            wordEnd++;\n        }\n\n        return wordEnd;\n    }\n\n    findPreviousWordBoundary(text, cursor) {\n        let pos = cursor;\n\n        if (pos <= 0) {\n            return 0;\n        }\n\n        pos--;\n\n        while (pos > 0 && (text[pos] === ' ' || text[pos] === '\\n')) {\n            pos--;\n        }\n\n        while (pos > 0 && text[pos - 1] !== ' ' && text[pos - 1] !== '\\n') {\n            pos--;\n        }\n\n        return pos;\n    }\n\n    skipToEnd() {\n        if (this.replayInProgress) {\n            this.replayInProgress = false;\n        }\n        let textOutput = \"\";\n        this.logData.forEach(event => {\n            if (event.event.toLowerCase() === 'keydown') {\n                textOutput = this.applyKey(event.key, textOutput);\n            }\n        });\n        this.outputElement.innerHTML = textOutput.slice(0, -1);\n        this.setScrubberVal(100);\n    }\n\n    // Used by the scrubber to skip to a certain percentage of data\n    skipToTime(percentage) {\n        const wasPlaying = this.replayInProgress;\n        if (wasPlaying) {\n            this.replayInProgress = false;\n            clearTimeout(this.replayTimeout);\n        }\n\n        const targetTime = (this.totalDuration * percentage) / 100;\n        this.initializeReplayState(targetTime);\n\n        for (let i = 0; i < this.logData.length; i++) {\n            const event = this.logData[i];\n            if (event.normalizedTime && event.normalizedTime > targetTime) {\n                this.currentEventIndex = i;\n                break;\n            }\n            this.handleReplayEvent(event, i, targetTime);\n        }\n\n        this.highlightedChars = this.removeExpiredHighlights(this.tempHighlights, targetTime);\n        this.deletedChars = this.removeExpiredDeletions(this.tempDeletions, targetTime);\n\n        this.text = this.replayText;\n        this.cursorPosition = this.replayCursor;\n        this.updateDisplayText(this.text, this.cursorPosition, this.highlightedChars, this.deletedChars);\n        this.setScrubberVal(percentage);\n\n        if (wasPlaying) {\n            this.replayInProgress = true;\n            this.replayLog();\n        }\n    }\n\n    initializeReplayState(targetTime) {\n        this.currentTime = targetTime;\n        this.currentEventIndex = 0;\n        this.text = '';\n        this.cursorPosition = 0;\n        this.highlightedChars = [];\n        this.deletedChars = [];\n        this.isControlKeyPressed = false;\n        this.isPasteEvent = false;\n\n        this.replayText = '';\n        this.replayCursor = 0;\n        this.tempHighlights = [];\n        this.tempDeletions = [];\n    }\n\n    handleReplayEvent(event, index, targetTime) {\n        if (event.rePosition !== undefined && (index === 0 || event.event === 'mouseDown' || event.event === 'mouseUp')) {\n            this.replayCursor = Math.max(0, Math.min(event.rePosition, this.replayText.length));\n        }\n\n        if (event.event?.toLowerCase() === \"keydown\") {\n            this.handleKeyInputDuringReplay(event, targetTime);\n        }\n\n        this.currentEventIndex = index + 1;\n    }\n\n    handleKeyInputDuringReplay(event, targetTime) {\n        const key = event.key;\n        const charToInsert = this.applyKey(key);\n\n        this.updateModifierKeyStates(key);\n\n        if (key === \"Backspace\" && this.isControlKeyPressed) {\n            this.deletePreviousWordReplay(targetTime);\n        } else if (key === \"Delete\" && this.isControlKeyPressed) {\n            this.deleteNextWordReplay(targetTime);\n        } else if (key === \"ArrowLeft\" && this.isControlKeyPressed) {\n            this.replayCursor = this.findPreviousWordBoundary(this.replayText, this.replayCursor);\n        } else if (key === \"ArrowRight\" && this.isControlKeyPressed) {\n            this.replayCursor = this.findNextWordBoundary(this.replayText, this.replayCursor);\n        } else if (key === \"Backspace\") {\n            this.deleteCharacterBeforeCursor(targetTime);\n        } else if (key === \"Delete\") {\n            this.deleteCharacterAtCursor(targetTime);\n        } else if (key === \"ArrowLeft\") {\n            this.replayCursor = Math.max(0, this.replayCursor - 1);\n        } else if (key === \"ArrowRight\") {\n            this.replayCursor = Math.min(this.replayText.length, this.replayCursor + 1);\n        } else if (charToInsert?.length > 0) {\n            this.insertCharacterReplay(charToInsert, targetTime);\n        }\n    }\n\n    updateModifierKeyStates(key) {\n        if (key === \"Control\") {\n            this.isControlKeyPressed = true;\n        } else if (key !== \"v\") {\n            this.isControlKeyPressed = false;\n            this.isPasteEvent = false;\n        } else if (key === \"v\" && this.isControlKeyPressed) {\n            this.isPasteEvent = true;\n            this.isControlKeyPressed = false;\n        }\n    }\n\n    deletePreviousWordReplay(targetTime) {\n        if (this.replayCursor > 0) {\n            let start = this.replayCursor;\n            while (start > 0 && this.replayText[start - 1] === ' ') {\n                start--;\n            }\n            while (start > 0 && this.replayText[start - 1] !== ' ') {\n                start--;\n            }\n\n            const deletedWord = this.replayText.substring(start, this.replayCursor);\n            for (let i = 0; i < deletedWord.length; i++) {\n                this.tempDeletions.push({\n                    index: start + i,\n                    \"char\": deletedWord[i],\n                    time: targetTime,\n                    expiresAt: targetTime + 2000\n                });\n            }\n\n            this.replayText = this.replayText.slice(0, start) + this.replayText.slice(this.replayCursor);\n            this.replayCursor = start;\n        }\n        this.isControlKeyPressed = false;\n    }\n\n    deleteNextWordReplay(targetTime) {\n        if (this.replayCursor < this.replayText.length) {\n            const end = this.findNextWordBoundary(this.replayText, this.replayCursor);\n            const word = this.replayText.slice(this.replayCursor, end);\n\n            for (let i = 0; i < word.length; i++) {\n                this.tempDeletions.push({\n                    index: this.replayCursor + i,\n                    \"char\": word[i],\n                    time: targetTime,\n                    expiresAt: targetTime + 2000\n                });\n            }\n\n            this.replayText = this.replayText.slice(0, this.replayCursor) + this.replayText.slice(end);\n        }\n        this.isControlKeyPressed = false;\n    }\n\n    deleteCharacterBeforeCursor(targetTime) {\n        if (this.replayCursor > 0 && !this.isPasteEvent) {\n            this.tempDeletions.push({\n                index: this.replayCursor - 1,\n                \"char\": this.replayText[this.replayCursor - 1],\n                time: targetTime,\n                expiresAt: targetTime + 2000\n            });\n            this.replayText = this.replayText.slice(0, this.replayCursor - 1) + this.replayText.slice(this.replayCursor);\n            this.replayCursor--;\n        }\n    }\n\n    deleteCharacterAtCursor(targetTime) {\n        if (this.replayCursor < this.replayText.length) {\n            this.tempDeletions.push({\n                index: this.replayCursor,\n                \"char\": this.replayText[this.replayCursor],\n                time: targetTime,\n                expiresAt: targetTime + 2000\n            });\n            this.replayText = this.replayText.slice(0, this.replayCursor) + this.replayText.slice(this.replayCursor + 1);\n        }\n    }\n\n    insertCharacterReplay(char, targetTime) {\n        this.replayText = this.replayText.slice(0, this.replayCursor) + char + this.replayText.slice(this.replayCursor);\n        if (char.trim() !== \"\") {\n            this.tempHighlights.push({\n                index: this.replayCursor,\n                \"char\": char,\n                time: targetTime,\n                expiresAt: targetTime + 1500\n            });\n        }\n        this.replayCursor++;\n    }\n\n    removeExpiredHighlights(highlights, time) {\n        return highlights.filter(h => !h.expiresAt || h.expiresAt > time);\n    }\n\n    removeExpiredDeletions(deletions, time) {\n        return deletions.filter(d => !d.expiresAt || d.expiresAt > time);\n    }\n\n\n    // Update display with text, cursor, highlights and deletions\n    updateDisplayText(text, cursorPosition, highlights, deletions) {\n        let html = '';\n        const highlightMap = {};\n        const deletionMap = {};\n        const currentTime = this.currentTime;\n\n        highlights.forEach(h => {\n            let opacity = 1;\n            if (h.expiresAt) {\n                const timeRemaining = h.expiresAt - currentTime;\n                if (timeRemaining < 500) {\n                    opacity = Math.max(0, timeRemaining / 500);\n                }\n            }\n            highlightMap[h.index] = {\"char\": h.char, opacity: opacity};\n        });\n\n        deletions.forEach(d => {\n            let opacity = 0.5;\n            if (d.expiresAt) {\n                const timeRemaining = d.expiresAt - currentTime;\n                if (timeRemaining < 500) {\n                    opacity = Math.max(0, (timeRemaining / 500) * 0.5);\n                }\n            }\n            deletionMap[d.index] = {\"char\": d.char, opacity: opacity};\n        });\n\n        // Find if we have out-of-bounds deletions (from Control+Backspace)\n        const outOfRangeDeletions = deletions.filter(d => d.index >= text.length);\n\n        const textLines = text.split('\\n');\n        let currentPosition = 0;\n\n        for (let lineIndex = 0; lineIndex < textLines.length; lineIndex++) {\n            const line = textLines[lineIndex];\n\n            for (let i = 0; i < line.length; i++) {\n                if (currentPosition === cursorPosition) {\n                    html += '<span class=\"tiny_cursive-cursor\"></span>';\n                }\n\n                const char = line[i];\n\n                if (deletionMap[currentPosition]) {\n                    const deletion = deletionMap[currentPosition];\n                    html += `<span class=\"tiny_cursive-deleted-char\" style=\"opacity: ${deletion.opacity};\">${deletion.char}</span>`;\n                }\n\n                if (highlightMap[currentPosition] && char !== ' ') {\n                    const highlight = highlightMap[currentPosition];\n                    html += `<span class=\"tiny_cursive-highlighted-char\" style=\"opacity: ${highlight.opacity};\">${char}</span>`;\n                } else {\n                    html += char === ' ' ? '&nbsp;' : this.escapeHtml(char);\n                }\n\n                currentPosition++;\n            }\n\n            if (currentPosition === cursorPosition) {\n                html += '<span class=\"tiny_cursive-cursor\"></span>';\n            }\n\n            if (lineIndex < textLines.length - 1) {\n                html += '<br>';\n                currentPosition++;\n            }\n        }\n\n        if (cursorPosition === text.length && !html.endsWith('<span class=\"tiny_cursive-cursor\"></span>')) {\n            html += '<span class=\"tiny_cursive-cursor\"></span>';\n        }\n\n        // For control + backspace functionalities\n        if (outOfRangeDeletions.length > 0) {\n            outOfRangeDeletions.sort((a, b) => a.index - b.index);\n\n            const cursorHTML = '<span class=\"tiny_cursive-cursor\"></span>';\n            let cursorPos = html.lastIndexOf(cursorHTML);\n\n            if (cursorPos !== -1) {\n                let deletedWordHTML = '<span class=\"tiny_cursive-deleted-char\" style=\"opacity: 0.5;\">';\n                outOfRangeDeletions.forEach(d => {\n                    deletedWordHTML += d.char;\n                });\n                deletedWordHTML += '</span>';\n                html = html.substring(0, cursorPos) + deletedWordHTML + html.substring(cursorPos);\n            }\n        }\n\n        const wasScrolledToBottom = this.outputElement.scrollHeight -\n            this.outputElement.clientHeight <= this.outputElement.scrollTop + 1;\n\n        this.outputElement.innerHTML = html;\n\n        if (wasScrolledToBottom || this.isCursorBelowViewport()) {\n            this.outputElement.scrollTop = this.outputElement.scrollHeight;\n        }\n    }\n\n    // Check if cursor is below visible viewport\n    isCursorBelowViewport() {\n        const cursorElement = this.outputElement.querySelector('.tiny_cursive-cursor:last-of-type');\n        if (!cursorElement) {\n            return false;\n        }\n\n        const cursorRect = cursorElement.getBoundingClientRect();\n        const outputRect = this.outputElement.getBoundingClientRect();\n\n        return cursorRect.bottom > outputRect.bottom;\n    }\n\n    escapeHtml(unsafe) {\n        return unsafe\n            .replace(/&/g, \"&amp;\")\n            .replace(/</g, \"&lt;\")\n            .replace(/>/g, \"&gt;\")\n            .replace(/\"/g, \"&quot;\")\n            .replace(/'/g, \"&#039;\");\n    }\n\n    // Used in various places to add a keydown, backspace, etc. to the output\n    applyKey(key) {\n        switch (key) {\n            case \"Enter\":\n                return \"\\n\";\n            case \"Backspace\":\n            case \"Delete\":\n                return \"\";\n            case \"ControlBackspace\":\n                return \"\";\n            case \" \":\n                return \" \";\n            default:\n                return ![\"Shift\", \"Ctrl\", \"Alt\", \"ArrowDown\", \"ArrowUp\", \"Control\", \"ArrowRight\",\n                    \"ArrowLeft\", \"Meta\", \"CapsLock\", \"Tab\", \"Escape\", \"Delete\", \"PageUp\", \"PageDown\",\n                    \"Insert\", \"Home\", \"End\", \"NumLock\", \"Insert\", \"Home\", \"End\", \"NumLock\", \"AudioVolumeUp\",\n                    \"AudioVolumeDown\", \"MediaPlayPause\", \"F1\", \"F2\", \"F3\", \"F4\", \"F5\", \"F6\", \"F7\", \"F8\", \"F9\",\n                    \"F10\", \"F11\", \"F12\", \"PrintScreen\", \"UnIdentified\"]\n                    .includes(key) ? key : \"\";\n        }\n    }\n}"],"names":["controllerId","constructor","elementId","filePath","speed","loop","replayInProgress","parseFloat","highlightedChars","deletedChars","cursorPosition","currentEventIndex","totalEvents","currentTime","totalDuration","usercomments","pasteTimestamps","isPasteEvent","element","document","getElementById","Error","outputElement","loadJSON","then","data","status","val","JSON","parse","logData","comments","Array","isArray","this","payload","length","unixTimestamp","startTime","map","event","normalizedTime","identifyPasteEvents","constructController","startReplay","Promise","all","templates","render","Str","get_string","results","html","str","newElement","text","catch","error","window","console","message","stopReplay","clearTimeout","replayTimeout","playSvg","createElement","src","M","util","image_url","playButton","querySelector","innerHTML","outerHTML","currentPosition","replayIntervalId","clearInterval","container","controlContainer","topRow","classList","add","className","addEventListener","playImg","find","removeClass","addClass","appendChild","scrubberContainer","scrubberElement","type","max","min","value","scrubberValue","parseInt","skipToTime","timeDisplay","textContent","bottomRow","speedContainer","speedLabel","speedGroup","forEach","speedValue","speedBtn","dataset","querySelectorAll","btn","remove","existingPanel","pasteEventsToggle","pasteEventsIcon","pasteIcon","pasteEventsText","pasteEventCount","style","marginLeft","chevronIcon","chevron","transition","pasteEventsPanel","display","populatePasteEventsPanel","isHidden","transform","controlPressed","pasteCount","i","toLowerCase","key","timestamp","userComment","push","index","time","formattedTime","formatTime","pastedText","lastIndex","panel","firstChild","removeChild","pasteEvents","noEventsMessage","carouselContainer","navigationRow","counterDisplay","navButtons","prevButton","leftChevron","nextButton","rightChevron","disabled","contentContainer","createPasteEventDisplay","pasteEvent","eventRow","headerRow","textContainer","timestampContainer","pastedTextContainer","playIcon","jumpToTimestamp","currentIndex","updatePasteEventDisplay","opacity","percentage","setScrubberVal","String","displayTime","Math","currentTimeFormatted","totalTimeFormatted","methodname","args","filepath","done","response","fail","ms","seconds","floor","remainingSeconds","toString","padStart","reset","isControlKeyPressed","pauseSvg","replayLog","updatedText","updatedCursor","updatedHighlights","updatedDeleted","processEvent","updateDisplayText","updateReplayStatus","cursor","highlights","deletions","undefined","rePosition","handleKeydown","filter","h","expiresAt","d","charToInsert","applyKey","insertChar","char","slice","trim","handleCtrlBackspace","handleCtrlDelete","findPreviousWordBoundary","findNextWordBoundary","handleBackspace","handleDelete","wordStart","word","wordEnd","percentComplete","baseIncrement","incrementTime","setTimeout","lastNonSpace","pos","skipToEnd","textOutput","wasPlaying","targetTime","initializeReplayState","handleReplayEvent","removeExpiredHighlights","tempHighlights","removeExpiredDeletions","tempDeletions","replayText","replayCursor","handleKeyInputDuringReplay","updateModifierKeyStates","deletePreviousWordReplay","deleteNextWordReplay","deleteCharacterBeforeCursor","deleteCharacterAtCursor","insertCharacterReplay","start","deletedWord","substring","end","highlightMap","deletionMap","timeRemaining","outOfRangeDeletions","textLines","split","lineIndex","line","deletion","escapeHtml","endsWith","sort","a","b","cursorHTML","cursorPos","lastIndexOf","deletedWordHTML","wasScrolledToBottom","scrollHeight","clientHeight","scrollTop","isCursorBelowViewport","cursorElement","cursorRect","getBoundingClientRect","outputRect","bottom","unsafe","replace","includes"],"mappings":"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"}