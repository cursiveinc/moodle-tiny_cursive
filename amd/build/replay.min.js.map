{"version":3,"file":"replay.min.js","sources":["../src/replay.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * @module     tiny_cursive/replay\n * @category TinyMCE Editor\n * @copyright  CTI <info@cursivetechnology.com>\n * @author kuldeep singh <mca.kuldeep.sekhon@gmail.com>\n */\n\nimport {call as fetchJson} from 'core/ajax';\nimport templates from 'core/templates';\nimport $ from 'jquery';\nimport * as Str from 'core/str';\n\nexport default class Replay {\n    constructor(elementId, filePath, speed = 1, loop = false, controllerId) {\n        // Initialize core properties\n        this.controllerId = controllerId || '';\n        this.replayInProgress = false;\n        this.speed = parseFloat(speed);\n        this.loop = loop;\n        this.highlightedChars = [];\n        this.deletedChars = [];\n        this.cursorPosition = 0;\n        this.currentEventIndex = 0;\n        this.totalEvents = 0;\n        this.currentTime = 0;\n        this.totalDuration = 0;\n        this.usercomments = [];\n        this.pasteTimestamps = [];\n        this.isPasteEvent = false;\n        this.isControlKeyPressed = false;\n        this.isShiftKeyPressed = false;\n        this.isMetaKeyPressed = false;\n        this.text = '';\n        this.pastedEvents = [];\n        this.currentPasteIndex = 0;\n        this.pastedChars = [];\n        this.aiEvents = [];\n        this.currentAiIndex = 0;\n        this.aiChars = [];\n\n        const element = document.getElementById(elementId);\n        if (!element) {\n            throw new Error(`Element with id '${elementId}' not found`);\n        }\n        this.outputElement = element;\n\n        // Load JSON data and initialize replay\n        this.loadJSON(filePath).then(data => {\n            if (data.status) {\n                this.processData(data);\n                this.totalEvents = this.logData.length;\n                this.identifyPasteEvents();\n                if (this.controllerId && this.logData) {\n                    this.constructController(this.controllerId);\n                }\n                this.startReplay();\n            } else {\n                this.handleNoSubmission();\n            }\n            return data;\n        }).catch(error => {\n            this.handleNoSubmission();\n            window.console.error('Error loading JSON file:', error.message);\n        });\n        if (!localStorage.getItem('nopasteevent') || !localStorage.getItem('pasteEvent')) {\n            Str.get_string('nopasteevent', 'tiny_cursive').then(str => {\n                localStorage.setItem('nopasteevent', str);\n                return str;\n            }).catch(error => window.console.log(error));\n            Str.get_string('pasteEvent', 'tiny_cursive').then(str => {\n                localStorage.setItem('pasteEvent', str);\n                return str;\n            }).catch(error => window.console.log(error));\n        }\n    }\n\n    // Process JSON data and normalize timestamps\n    processData(data) {\n        this.logData = JSON.parse(data.data);\n        if (data.comments) {\n            this.usercomments = Array.isArray(JSON.parse(data.comments)) ? JSON.parse(data.comments) : [];\n        }\n        window.console.log(JSON.stringify(this.logData));\n        if ('data' in this.logData) {\n            this.logData = this.logData.data;\n        }\n        if ('payload' in this.logData) {\n            this.logData = this.logData.payload;\n        }\n        for (let i = 0; i < this.logData.length; i++) {\n            const event = this.logData[i];\n            if (event.event === 'Paste') {\n                if (typeof event.pastedContent === 'string' && event.pastedContent.trim() !== '') {\n                    this.pastedEvents.push(event.pastedContent);\n                }\n            }\n            if (event.event === 'aiInsert' && event.aiContent) {\n                this.aiEvents.push(event.aiContent);\n            }\n        }\n        if (this.logData.length > 0 && this.logData[0].unixTimestamp) {\n            const startTime = this.logData[0].unixTimestamp;\n            this.logData = this.logData.map(event => ({\n                ...event,\n                normalizedTime: event.unixTimestamp - startTime\n            }));\n            this.totalDuration = this.logData[this.logData.length - 1].normalizedTime;\n        }\n    }\n\n    async handleNoSubmission() {\n        try {\n            const [html, str] = await Promise.all([\n                templates.render('tiny_cursive/no_submission'),\n                Str.get_string('warningpayload', 'tiny_cursive')\n            ]);\n            const newElement = $(html).text(str);\n            return $('.tiny_cursive').html(newElement);\n        } catch (error) {\n            window.console.error(error);\n            return false;\n        }\n    }\n\n    // Stop the replay and update play button icon\n    stopReplay() {\n        if (this.replayInProgress) {\n            clearTimeout(this.replayTimeout);\n            this.replayInProgress = false;\n            if (this.playButton) {\n                const playSvg = document.createElement('img');\n                playSvg.src = M.util.image_url('playicon', 'tiny_cursive');\n                this.playButton.querySelector('.play-icon').innerHTML = playSvg.outerHTML;\n            }\n        }\n    }\n\n    // Build the replay control UI (play button, scrubber, speed controls)\n    constructController(controllerId) {\n        this.replayInProgress = false;\n        this.currentPosition = 0;\n        this.speed = 1;\n        if (this.replayIntervalId) {\n            clearInterval(this.replayIntervalId);\n            this.replayIntervalId = null;\n        }\n\n        const container = document.getElementById(controllerId);\n        if (!container) {\n            window.console.error('Container not found with ID:', controllerId);\n            return;\n        }\n\n        const controlContainer = container.querySelector('.tiny_cursive_replay_control');\n        if (!controlContainer) {\n            window.console.error('Replay control container not found in:', controllerId);\n            return;\n        }\n        controlContainer.innerHTML = '<span class=\"tiny_cursive_loading_spinner\"></span>';\n\n        this.buildControllerUI(controlContainer, container);\n        controlContainer.querySelector('.tiny_cursive_loading_spinner')?.remove();\n    }\n\n    buildControllerUI(controlContainer, container) {\n        const topRow = document.createElement('div');\n        topRow.classList.add('tiny_cursive_top_row');\n\n        this.playButton = this.createPlayButton();\n        topRow.appendChild(this.playButton);\n\n        const scrubberContainer = this.createScrubberContainer();\n        topRow.appendChild(scrubberContainer);\n\n        this.timeDisplay = this.createTimeDisplay();\n        topRow.appendChild(this.timeDisplay);\n\n        const bottomRow = document.createElement('div');\n        bottomRow.classList.add('tiny_cursive_bottom_row');\n\n        const speedContainer = this.createSpeedControls();\n        bottomRow.appendChild(speedContainer);\n\n        const pasteEventsToggle = this.createPasteEventsToggle(container);\n        bottomRow.appendChild(pasteEventsToggle);\n\n        controlContainer.appendChild(topRow);\n        controlContainer.appendChild(bottomRow);\n        container.appendChild(this.pasteEventsPanel);\n    }\n\n    createPlayButton() {\n        const playButton = document.createElement('button');\n        playButton.classList.add('tiny_cursive_play_button');\n        const playSvg = document.createElement('i');\n        playButton.innerHTML = `<span class=\"play-icon\">${playSvg.outerHTML}</span>`;\n        playButton.addEventListener('click', () => {\n            if (this.replayInProgress) {\n                this.stopReplay();\n            } else {\n                this.startReplay(false);\n            }\n            $('.tiny_cursive-nav-tab').find('.active').removeClass('active');\n            $('a[id^=\"rep\"]').addClass('active');\n        });\n        return playButton;\n    }\n\n    createScrubberContainer() {\n        const scrubberContainer = document.createElement('div');\n        scrubberContainer.classList.add('tiny_cursive_scrubber_container');\n        this.scrubberElement = document.createElement('input');\n        this.scrubberElement.classList.add('tiny_cursive_timeline_scrubber', 'timeline-scrubber');\n        this.scrubberElement.type = 'range';\n        this.scrubberElement.max = '100';\n        this.scrubberElement.min = '0';\n        this.scrubberElement.value = '0';\n        this.scrubberElement.addEventListener('input', () => {\n            this.skipToTime(parseInt(this.scrubberElement.value, 10));\n        });\n        scrubberContainer.appendChild(this.scrubberElement);\n        return scrubberContainer;\n    }\n\n    createTimeDisplay() {\n        const timeDisplay = document.createElement('div');\n        timeDisplay.classList.add('tiny_cursive_time_display');\n        timeDisplay.textContent = '00:00 / 00:00';\n        return timeDisplay;\n    }\n\n    createSpeedControls() {\n        const speedContainer = document.createElement('div');\n        speedContainer.classList.add('tiny_cursive_speed_controls', 'speed-controls');\n        const speedLabel = document.createElement('span');\n        speedLabel.classList.add('tiny_cursive_speed_label');\n        speedLabel.textContent = 'Speed: ';\n        speedContainer.appendChild(speedLabel);\n\n        const speedGroup = document.createElement('div');\n        speedGroup.classList.add('tiny_cursive_speed_group');\n        [1, 1.5, 2, 5, 10].forEach(speed => {\n            const speedBtn = document.createElement('button');\n            speedBtn.textContent = `${speed}x`;\n            speedBtn.classList.add('tiny_cursive_speed_btn', 'speed-btn');\n            if (parseFloat(speed) === this.speed) {\n                speedBtn.classList.add('active');\n            }\n            speedBtn.dataset.speed = speed;\n            speedBtn.addEventListener('click', () => {\n                document.querySelectorAll('.tiny_cursive_speed_btn').forEach(btn => btn.classList.remove('active'));\n                speedBtn.classList.add('active');\n                this.speed = parseFloat(speedBtn.dataset.speed);\n                if (this.replayInProgress) {\n                    this.stopReplay();\n                    this.startReplay(false);\n                }\n            });\n            speedGroup.appendChild(speedBtn);\n        });\n        speedContainer.appendChild(speedGroup);\n        return speedContainer;\n    }\n\n    createPasteEventsToggle(container) {\n        const pasteEventsToggle = document.createElement('div');\n        pasteEventsToggle.classList.add('tiny_cursive_paste_events_toggle', 'paste-events-toggle');\n\n        const pasteEventsIcon = document.createElement('span');\n        const pasteIcon = document.createElement('img');\n        pasteIcon.src = M.util.image_url('pasteicon', 'tiny_cursive');\n        pasteEventsIcon.innerHTML = pasteIcon.outerHTML;\n        pasteEventsIcon.classList.add('tiny_cursive_paste_events_icon');\n\n        const pasteEventsText = document.createElement('span');\n        pasteEventsText.textContent = localStorage.getItem('pasteEvent');\n\n        this.pasteEventCount = document.createElement('span');\n        this.pasteEventCount.textContent = `(${this.pasteTimestamps.length})`;\n        this.pasteEventCount.className = 'paste-event-count';\n        this.pasteEventCount.style.marginLeft = '2px';\n\n        const chevronIcon = document.createElement('span');\n        const chevron = document.createElement('i');\n        chevron.className = 'fa fa-chevron-down';\n        chevronIcon.innerHTML = chevron.outerHTML;\n        chevronIcon.style.marginLeft = '5px';\n        chevronIcon.style.transition = 'transform 0.3s ease';\n\n        pasteEventsToggle.appendChild(pasteEventsIcon);\n        pasteEventsToggle.appendChild(pasteEventsText);\n        pasteEventsToggle.appendChild(this.pasteEventCount);\n        pasteEventsToggle.appendChild(chevronIcon);\n\n        this.pasteEventsPanel = this.createPasteEventsPanel(container);\n        pasteEventsToggle.addEventListener('click', () => {\n            const isHidden = this.pasteEventsPanel.style.display === 'none';\n            this.pasteEventsPanel.style.display = isHidden ? 'block' : 'none';\n            chevronIcon.style.transform = isHidden ? 'rotate(180deg)' : 'rotate(0deg)';\n        });\n\n        return pasteEventsToggle;\n    }\n\n    createPasteEventsPanel(container) {\n        const existingPanel = container.querySelector('.paste-events-panel');\n        if (existingPanel) {\n            existingPanel.remove();\n        }\n        const pasteEventsPanel = document.createElement('div');\n        pasteEventsPanel.classList.add('tiny_cursive_paste_events_panel', 'paste-events-panel');\n        pasteEventsPanel.style.display = 'none';\n        this.populatePasteEventsPanel(pasteEventsPanel);\n        return pasteEventsPanel;\n    }\n\n    // Detect Ctrl+V paste events and sync with user comments\n    identifyPasteEvents() {\n        this.pasteTimestamps = [];\n        let controlPressed = false;\n        let metaPressed = false;\n        /* eslint-disable no-unused-vars */\n        let shiftPressed = false;\n        let pasteCount = 0;\n\n        for (let i = 0; i < this.logData.length; i++) {\n            const event = this.logData[i];\n            if (event.event?.toLowerCase() === 'keydown') {\n                if (event.key === 'Control') {\n                    controlPressed = true;\n                } else if (event.key === 'Meta') {\n                    metaPressed = true;\n                } else if (event.key === 'Shift') {\n                    shiftPressed = true;\n                } else if ((event.key === 'v' || event.key === 'V') && (controlPressed || metaPressed)) {\n                    if (this.pastedEvents[pasteCount]) {\n                        const timestamp = event.normalizedTime || 0;\n                        this.pasteTimestamps.push({\n                            index: pasteCount,\n                            time: timestamp,\n                            formattedTime: this.formatTime(timestamp),\n                            pastedText: this.pastedEvents[pasteCount],\n                            timestamp\n                        });\n                    }\n                    pasteCount++;\n                    controlPressed = false;\n                    shiftPressed = false;\n                    metaPressed = false;\n                } else {\n                    controlPressed = false;\n                    shiftPressed = false;\n                    metaPressed = false;\n                }\n            }\n        }\n\n        if (this.pasteEventsPanel) {\n            this.populatePasteEventsPanel(this.pasteEventsPanel);\n        }\n    }\n\n    // Populate the paste events panel with navigation\n    populatePasteEventsPanel(panel) {\n        panel.innerHTML = '';\n        panel.classList.add('tiny_cursive_event_panel');\n\n        if (!this.pasteTimestamps.length) {\n            const noEventsMessage = document.createElement('div');\n            noEventsMessage.className = 'no-paste-events-message p-3';\n            noEventsMessage.textContent = localStorage.getItem('nopasteevent');\n            panel.appendChild(noEventsMessage);\n            return;\n        }\n\n        const carouselContainer = document.createElement('div');\n        carouselContainer.classList.add('tiny_cursive_paste_events_carousel', 'paste-events-carousel');\n\n        const navigationRow = document.createElement('div');\n        navigationRow.classList.add('paste-events-navigation', 'tiny_cursive_navigation_row');\n\n        const counterDisplay = document.createElement('div');\n        counterDisplay.classList.add('paste-events-counter', 'tiny_cursive_counter_display');\n        counterDisplay.textContent = 'Paste Events';\n\n        const navButtons = document.createElement('div');\n        navButtons.classList.add('tiny_cursive_nav_buttons');\n        const prevButton = document.createElement('button');\n        prevButton.classList.add('paste-event-prev-btn', 'tiny_cursive_nav_button');\n        prevButton.innerHTML = '<i class=\"fa fa-chevron-left\"></i>';\n\n        const nextButton = document.createElement('button');\n        nextButton.classList.add('paste-event-next-btn', 'tiny_cursive_nav_button');\n        nextButton.innerHTML = '<i class=\"fa fa-chevron-right\"></i>';\n        nextButton.disabled = this.pasteTimestamps.length <= 1;\n\n        navButtons.appendChild(prevButton);\n        navButtons.appendChild(nextButton);\n        navigationRow.appendChild(counterDisplay);\n        navigationRow.appendChild(navButtons);\n\n        const contentContainer = document.createElement('div');\n        contentContainer.className = 'paste-events-content tiny_cursive_content_container';\n        contentContainer.appendChild(this.createPasteEventDisplay(this.pasteTimestamps[0]));\n\n        carouselContainer.appendChild(navigationRow);\n        carouselContainer.appendChild(contentContainer);\n        panel.appendChild(carouselContainer);\n\n        let currentIndex = 0;\n        const updateDisplay = () => {\n            contentContainer.innerHTML = '';\n            contentContainer.appendChild(this.createPasteEventDisplay(this.pasteTimestamps[currentIndex]));\n            counterDisplay.textContent = 'Paste Events';\n            prevButton.disabled = currentIndex === 0;\n            prevButton.style.opacity = currentIndex === 0 ? '0.5' : '1';\n            nextButton.disabled = currentIndex === this.pasteTimestamps.length - 1;\n            nextButton.style.opacity = currentIndex === this.pasteTimestamps.length - 1 ? '0.5' : '1';\n        };\n\n        prevButton.addEventListener('click', () => {\n            if (currentIndex > 0) {\n                currentIndex--;\n                updateDisplay();\n            }\n        });\n\n        nextButton.addEventListener('click', () => {\n            if (currentIndex < this.pasteTimestamps.length - 1) {\n                currentIndex++;\n                updateDisplay();\n            }\n        });\n    }\n\n    createPasteEventDisplay(pasteEvent) {\n        const eventRow = document.createElement('div');\n        eventRow.className = 'tiny_cursive_event_row';\n\n        const headerRow = document.createElement('div');\n        headerRow.className = 'tiny_cursive_header_row';\n\n        const textContainer = document.createElement('div');\n        textContainer.className = 'tiny_cursive_text_container';\n\n        const timestampContainer = document.createElement('div');\n        timestampContainer.className = 'paste-event-timestamp tiny_cursive_paste_event_timestamp';\n        timestampContainer.textContent = pasteEvent.formattedTime;\n\n        const pastedTextContainer = document.createElement('div');\n        pastedTextContainer.className = 'paste-event-text tiny_cursive_pasted_text_container';\n        pastedTextContainer.textContent = pasteEvent.pastedText;\n\n        textContainer.appendChild(timestampContainer);\n        textContainer.appendChild(pastedTextContainer);\n\n        const playButton = document.createElement('button');\n        playButton.className = 'paste-event-play-btn tiny_cursive_seekplay_button';\n        const playIcon = document.createElement('img');\n        playIcon.src = M.util.image_url('seekplayicon', 'tiny_cursive');\n        playButton.innerHTML = playIcon.outerHTML;\n        playButton.addEventListener('click', () => this.jumpToTimestamp(pasteEvent.timestamp));\n\n        headerRow.appendChild(textContainer);\n        headerRow.appendChild(playButton);\n        eventRow.appendChild(headerRow);\n\n        return eventRow;\n    }\n\n    // Jump to a specific timestamp in the replay\n    jumpToTimestamp(timestamp) {\n        const percentage = this.totalDuration > 0 ? (timestamp / this.totalDuration) * 100 : 0;\n        this.skipToTime(percentage);\n        if (!this.replayInProgress) {\n            this.startReplay(false);\n        }\n    }\n\n    setScrubberVal(value) {\n        if (this.scrubberElement) {\n            this.scrubberElement.value = String(value);\n            if (this.timeDisplay) {\n                const displayTime = Math.min(this.currentTime, this.totalDuration);\n                this.timeDisplay.textContent = `${this.formatTime(displayTime)} / ${this.formatTime(this.totalDuration)}`;\n            }\n        }\n    }\n\n    loadJSON(filePath) {\n        return fetchJson([{\n            methodname: 'cursive_get_reply_json',\n            args: {filepath: filePath}\n        }])[0].done(response => response).fail(error => {\n            throw new Error(`Error loading JSON file: ${error.message}`);\n        });\n    }\n\n    formatTime(ms) {\n        const seconds = Math.floor(ms / 1000);\n        const minutes = Math.floor(seconds / 60);\n        const remainingSeconds = seconds % 60;\n        return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;\n    }\n\n    // Start or restart the replay\n    startReplay(reset = true) {\n        if (this.replayInProgress) {\n            clearTimeout(this.replayTimeout);\n        }\n        const atEnd = (this.totalDuration > 0 && this.currentTime >= this.totalDuration) ||\n            (this.currentEventIndex >= this.totalEvents);\n        if (atEnd && !reset) {\n            reset = true;\n        }\n        this.replayInProgress = true;\n        if (reset) {\n            this.outputElement.innerHTML = '';\n            this.text = '';\n            this.cursorPosition = 0;\n            this.currentEventIndex = 0;\n            this.currentTime = 0;\n            this.highlightedChars = [];\n            this.deletedChars = [];\n            this.isControlKeyPressed = false;\n            this.isMetaKeyPressed = false;\n            this.currentPasteIndex = 0;\n            this.pastedChars = [];\n            this.currentAiIndex = 0;\n            this.aiChars = [];\n        }\n        if (this.playButton) {\n            const pauseSvg = document.createElement('i');\n            pauseSvg.className = 'fa fa-pause';\n            this.playButton.querySelector('.play-icon').innerHTML = pauseSvg.outerHTML;\n        }\n        this.replayLog();\n    }\n\n    // Process events in sequence to simulate typing\n    replayLog() {\n        if (!this.replayInProgress) {\n            this.updateDisplayText(this.text, this.cursorPosition, [], []);\n            return;\n        }\n\n        while (this.currentEventIndex < this.logData.length) {\n            const event = this.logData[this.currentEventIndex];\n            if (event.normalizedTime && event.normalizedTime > this.currentTime) {\n                break;\n            }\n\n            let text = this.text || '';\n            let cursor = this.cursorPosition;\n            let updatedHighlights = [...this.highlightedChars];\n            let updatedDeleted = [...this.deletedChars];\n\n            if (event.rePosition !== undefined && (this.currentEventIndex === 0 ||\n                event.event === 'mouseDown' || event.event === 'mouseUp')) {\n                cursor = Math.max(0, Math.min(event.rePosition, text.length));\n            }\n\n            if (event.event?.toLowerCase() === 'keydown') {\n                ({text, cursor, updatedHighlights, updatedDeleted} =\n                    this.processKeydownEvent(event, text, cursor, updatedHighlights, updatedDeleted));\n            } else if (event.event === 'aiInsert') {\n                ({text, cursor, updatedHighlights, updatedDeleted} =\n                    this.processAiInsertEvent(event, text, cursor, updatedHighlights, updatedDeleted));\n               }\n\n            this.text = text;\n            this.cursorPosition = cursor;\n            this.highlightedChars = updatedHighlights.filter(h => !h.expiresAt || h.expiresAt > this.currentTime);\n            this.deletedChars = updatedDeleted.filter(d => !d.expiresAt || d.expiresAt > this.currentTime);\n\n            this.currentEventIndex++;\n        }\n\n        this.updateDisplayText(this.text, this.cursorPosition, this.highlightedChars, this.deletedChars);\n        if (this.totalDuration > 0) {\n            const percentComplete = Math.min((this.currentTime / this.totalDuration) * 100, 100);\n            this.setScrubberVal(percentComplete);\n        }\n\n        if (this.replayInProgress) {\n            const baseIncrement = 100;\n            const incrementTime = baseIncrement / this.speed;\n            this.currentTime += baseIncrement;\n            if (this.currentEventIndex >= this.totalEvents) {\n                if (this.loop) {\n                    this.startReplay(true);\n                } else {\n                    this.stopReplay();\n                    this.updateDisplayText(this.text, this.cursorPosition, [], []);\n                }\n            } else {\n                this.replayTimeout = setTimeout(() => this.replayLog(), incrementTime);\n            }\n        }\n    }\n\n    getLineAndColumn(text, pos) {\n        const before = text.substring(0, pos);\n        const lineIndex = before.split('\\n').length - 1;\n        const col = before.length - before.lastIndexOf('\\n') - 1;\n        return {lineIndex, col};\n    }\n\n    processAiInsertEvent(event, text, cursor, highlights, deletions) {\n        if (this.aiEvents && this.currentAiIndex < this.aiEvents.length) {\n            const aiContent = this.aiEvents[this.currentAiIndex];\n            // Use event.rePosition which points to where the word to replace is\n            const targetPosition = event.rePosition;\n\n            ({text, cursor} = this.handleAiReplacement(aiContent, text, targetPosition, cursor, deletions));\n            this.currentAiIndex++;\n        }\n        return {\n            text,\n            cursor,\n            updatedHighlights: highlights,\n            updatedDeleted: deletions\n        };\n    }\n\n    handleAiReplacement(aiContent, text, targetPosition, currentCursor, deletions) {\n        const insertText = aiContent || '';\n        const aiWords = insertText.trim().split(/\\s+/);\n        const isMultiWord = aiWords.length > 1;\n        let wordStart = targetPosition;\n        let wordEnd = targetPosition;\n\n        const isNewLineInsertion = insertText.startsWith('\\n') || insertText.endsWith('\\n');\n\n        if (isNewLineInsertion) {\n            wordStart = currentCursor;\n            wordEnd = currentCursor;\n        } else {\n            let lineStart = 0;\n            for (let i = targetPosition - 1; i >= 0; i--) {\n                if (text[i] === '\\n') {\n                    lineStart = i + 1;\n                    break;\n                }\n            }\n\n            let lineEnd = text.length;\n            for (let i = targetPosition; i < text.length; i++) {\n                if (text[i] === '\\n') {\n                    lineEnd = i;\n                    break;\n                }\n            }\n\n            const lineText = text.substring(lineStart, lineEnd);\n\n            // Extract all words from the current line\n            const words = [];\n            let pos = 0;\n\n            while (pos < lineText.length) {\n                while (pos < lineText.length && lineText[pos] === ' ') {\n                    pos++;\n                }\n                if (pos >= lineText.length) {\n                    break;\n                }\n\n                const start = pos;\n                while (pos < lineText.length && lineText[pos] !== ' ') {\n                    pos++;\n                }\n\n                if (pos > start) {\n                    words.push({\n                        text: lineText.substring(start, pos),\n                        start: lineStart + start,\n                        end: lineStart + pos\n                    });\n                }\n            }\n\n            if (words.length === 0) {\n                wordStart = currentCursor;\n                wordEnd = currentCursor;\n            } else if (isMultiWord) {\n                let bestMatch = { start: -1, end: -1, score: -1, wordCount: 0, similarityScore: 0 };\n\n                for (let i = 0; i < words.length; i++) {\n                    let seqWords = [];\n\n                    for (let j = 0; j < aiWords.length && i + j < words.length; j++) {\n                        seqWords.push(words[i + j]);\n                    }\n\n                    if (seqWords.length === 0) {\n                        continue;\n                    }\n                    let similarityScore = 0;\n                    let positionScore = 0;\n                    const compareLength = Math.min(seqWords.length, aiWords.length);\n\n                    for (let k = 0; k < compareLength; k++) {\n                        const ai = aiWords[k].toLowerCase();\n                        const seq = seqWords[k].text.toLowerCase();\n\n                        if (ai === seq) {\n                            similarityScore += 10;\n                        } else {\n                            const similarity = this.calculateSimilarity(ai, seq);\n                            similarityScore += similarity * 10;\n                        }\n                    }\n\n                    const seqStart = seqWords[0].start;\n                    const seqEndPos = seqWords[seqWords.length - 1].end;\n\n                    if (targetPosition >= seqStart && targetPosition <= seqEndPos) {\n                        positionScore += 10;\n                        if (targetPosition >= seqWords[0].start && targetPosition <= seqWords[0].end) {\n                            positionScore += 5;\n                        }\n                    }\n\n                    const totalScore = similarityScore + positionScore + seqWords.length;\n\n                    // Prefer matches with higher similarity score\n                    if (totalScore > bestMatch.score ||\n                        (totalScore === bestMatch.score && similarityScore > bestMatch.similarityScore)) {\n                        bestMatch = {\n                            start: seqWords[0].start,\n                            end: seqWords[seqWords.length - 1].end,\n                            score: totalScore,\n                            wordCount: seqWords.length,\n                            similarityScore: similarityScore\n                        };\n                    }\n                }\n\n                if (bestMatch.score > 10) {\n                    wordStart = bestMatch.start;\n                    wordEnd = bestMatch.end;\n                } else {\n                    const closest = this.findClosestWord(words, targetPosition);\n                    wordStart = closest.start;\n                    wordEnd = closest.end;\n                }\n            } else {\n                const aiWord = aiWords[0].toLowerCase();\n                let bestSimilarityMatch = null;\n                let bestSimilarityScore = 0;\n\n                // Find the word with best similarity\n                for (const word of words) {\n                    let similarity = this.calculateSimilarity(aiWord, word.text.toLowerCase());\n\n                    const wordLower = word.text.toLowerCase();\n                    if (wordLower.length < aiWord.length * 0.5 && aiWord.startsWith(wordLower)) {\n                        similarity = similarity * 0.3;\n                    }\n\n                    if (similarity > bestSimilarityScore) {\n                        bestSimilarityScore = similarity;\n                        bestSimilarityMatch = word;\n                    }\n                }\n\n                // Use high similarity match if > 0.5\n                if (bestSimilarityScore > 0.5 && bestSimilarityMatch) {\n                    wordStart = bestSimilarityMatch.start;\n                    wordEnd = bestSimilarityMatch.end;\n                } else {\n                    // Fall back to position + similarity scoring\n                    let bestMatch = { word: null, score: -1 };\n\n                    for (const word of words) {\n                        let score = 0;\n\n                        // Position score\n                        if (targetPosition >= word.start && targetPosition <= word.end) {\n                            score += 30;\n                        } else {\n                            const distance = Math.min(\n                                Math.abs(targetPosition - word.start),\n                                Math.abs(targetPosition - word.end)\n                            );\n                            score += Math.max(0, 20 - distance);\n                        }\n\n                        // Similarity score with penalty for short prefix matches\n                        let similarity = this.calculateSimilarity(aiWord, word.text.toLowerCase());\n                        const wordLower = word.text.toLowerCase();\n                        if (wordLower.length < aiWord.length * 0.5 && aiWord.startsWith(wordLower)) {\n                            similarity = similarity * 0.3;\n                        }\n                        score += similarity * 10;\n\n                        if (score > bestMatch.score) {\n                            bestMatch = { word, score };\n                        }\n                    }\n\n                    if (bestMatch.word) {\n                        wordStart = bestMatch.word.start;\n                        wordEnd = bestMatch.word.end;\n                    } else {\n                        wordStart = targetPosition;\n                        while (wordStart > lineStart && text[wordStart - 1] !== ' ' && text[wordStart - 1] !== '\\n') {\n                            wordStart--;\n                        }\n                        wordEnd = targetPosition;\n                        while (wordEnd < lineEnd && text[wordEnd] !== ' ' && text[wordEnd] !== '\\n') {\n                            wordEnd++;\n                        }\n                    }\n                }\n            }\n        }\n\n        const wordToReplace = text.substring(wordStart, wordEnd);\n\n        // Mark replaced characters as deleted\n        if (wordToReplace.length > 0) {\n            for (let i = 0; i < wordToReplace.length; i++) {\n                deletions.push({\n                    index: wordStart + i,\n                    chars: wordToReplace[i],\n                    time: this.currentTime,\n                    expiresAt: this.currentTime + 2000\n                });\n            }\n        }\n\n        const replacedLength = wordToReplace.length;\n        text = text.substring(0, wordStart) + insertText + text.substring(wordEnd);\n        const positionDiff = insertText.length - replacedLength;\n\n        let newCursor = currentCursor;\n        if (isNewLineInsertion) {\n            newCursor = wordStart + insertText.length;\n        } else if (targetPosition >= wordStart && targetPosition <= wordEnd) {\n            newCursor = wordStart + insertText.length;\n        } else if (currentCursor >= wordEnd) {\n            newCursor = currentCursor + positionDiff;\n        } else if (currentCursor > wordStart && currentCursor < wordEnd) {\n            newCursor = wordStart + insertText.length;\n        }\n        // Update pasted character indices\n        if (this.pastedChars) {\n            this.pastedChars = this.pastedChars.map(p => {\n                if (p.index >= wordEnd) {\n                    return { ...p, index: p.index + positionDiff };\n                } else if (p.index >= wordStart && p.index < wordEnd) {\n                    return null;\n                }\n                return p;\n            }).filter(p => p !== null);\n        }\n\n        // Mark characters as AI-inserted\n        if (!this.aiChars) {\n            this.aiChars = [];\n        }\n\n        if (insertText.trim() !== '') {\n            for (let i = 0; i < insertText.length; i++) {\n                this.aiChars.push({\n                    index: wordStart + i,\n                    chars: insertText[i]\n                });\n            }\n        }\n\n        // Update AI character indices\n        const justAddedIndices = new Set();\n        for (let i = 0; i < insertText.length; i++) {\n            justAddedIndices.add(wordStart + i);\n        }\n\n        this.aiChars = this.aiChars.map(p => {\n            if (!justAddedIndices.has(p.index)) {\n                if (p.index >= wordEnd) {\n                    return { ...p, index: p.index + positionDiff };\n                } else if (p.index >= wordStart && p.index < wordEnd) {\n                    return null;\n                }\n            }\n            return p;\n        }).filter(p => p !== null);\n\n        return {text, cursor: newCursor};\n    }\n\n    // Calculate similarity between two strings\n    calculateSimilarity(str1, str2) {\n        if (str1 === str2) {\n            return 1;\n        }\n        if (str1.length === 0 || str2.length === 0) {\n            return 0;\n        }\n\n        // Check if one string is a prefix of the other\n        if (str1.startsWith(str2) || str2.startsWith(str1)) {\n            return 0.8;\n        }\n\n        // Levenshtein distance\n        const len1 = str1.length;\n        const len2 = str2.length;\n        const matrix = Array(len2 + 1).fill(null).map(() => Array(len1 + 1).fill(0));\n\n        for (let i = 0; i <= len1; i++) {\n            matrix[0][i] = i;\n        }\n        for (let j = 0; j <= len2; j++) {\n            matrix[j][0] = j;\n        }\n\n        for (let j = 1; j <= len2; j++) {\n            for (let i = 1; i <= len1; i++) {\n                const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;\n                matrix[j][i] = Math.min(\n                    matrix[j][i - 1] + 1,\n                    matrix[j - 1][i] + 1,\n                    matrix[j - 1][i - 1] + cost\n                );\n            }\n        }\n\n        const maxLen = Math.max(len1, len2);\n        return 1 - (matrix[len2][len1] / maxLen);\n    }\n\n    // Find the word closest to a target position\n    findClosestWord(words, targetPosition) {\n        if (words.length === 0) {\n            return { start: targetPosition, end: targetPosition };\n        }\n\n        let closest = words[0];\n        let minDistance = Math.min(\n            Math.abs(targetPosition - words[0].start),\n            Math.abs(targetPosition - words[0].end)\n        );\n\n        for (const word of words) {\n            if (targetPosition >= word.start && targetPosition <= word.end) {\n                return word;\n            }\n\n            const distance = Math.min(\n                Math.abs(targetPosition - word.start),\n                Math.abs(targetPosition - word.end)\n            );\n\n            if (distance < minDistance) {\n                minDistance = distance;\n                closest = word;\n            }\n        }\n\n        return closest;\n    }\n\n    // Handle keydown events (e.g., typing, backspace, Ctrl+V)\n    processKeydownEvent(event, text, cursor, highlights, deletions) {\n        const key = event.key;\n        const charToInsert = this.applyKey(key);\n        this.updateModifierStates(key);\n\n        // Check for selection before processing delete/backspace\n        const currentEventIndex = this.currentEventIndex;\n        const selection = this.detectSelection(currentEventIndex);\n\n        if ((key === 'v' || key === 'V') && (this.isControlKeyPressed || this.isMetaKeyPressed)) {\n            if (this.pastedEvents && this.currentPasteIndex < this.pastedEvents.length) {\n                const pastedContent = this.pastedEvents[this.currentPasteIndex];\n\n                if (selection) {\n                    ({text, cursor} = this.handleSelectionDeletion(selection, text, cursor, deletions));\n                }\n\n                ({text, cursor} = this.handlePasteInsert(pastedContent, text, cursor));\n                this.currentPasteIndex++;\n                this.isControlKeyPressed = false;\n                this.isShiftKeyPressed = false;\n                this.isMetaKeyPressed = false;\n                this.isPasteEvent = false;\n                return {\n                    text,\n                    cursor,\n                    updatedHighlights: highlights,\n                    updatedDeleted: deletions\n                };\n            }\n        }\n\n        // Handle Backspace and Delete\n        if ((key === 'Backspace' || key === 'Delete') && selection && selection.length > 1) {\n            ({text, cursor} = this.handleSelectionDeletion(selection, text, cursor, deletions));\n            return {\n                text,\n                cursor,\n                updatedHighlights: highlights,\n                updatedDeleted: deletions\n            };\n        }\n\n        if (this.isCtrlBackspace(key, cursor)) {\n            ({text, cursor} = this.handleCtrlBackspace(text, cursor, deletions));\n        } else if (this.isCtrlDelete(key, cursor, text)) {\n            ({text} = this.handleCtrlDelete(text, cursor, deletions));\n        } else if (this.isCtrlArrowMove(key)) {\n            cursor = this.handleCtrlArrowMove(key, text, cursor);\n        } else if (this.isRegularBackspace(key, cursor)) {\n            ({text, cursor} = this.handleBackspace(text, cursor, deletions));\n        } else if (this.isRegularDelete(key, cursor, text)) {\n            ({text} = this.handleDelete(text, cursor, deletions));\n        } else if (this.isArrowUp(key)) {\n            cursor = this.handleArrowUp(text, cursor);\n        } else if (this.isArrowDown(key)) {\n            cursor = this.handleArrowDown(text, cursor);\n        } else if (this.isRegularArrowMove(key)) {\n            cursor = this.handleArrowMove(key, text, cursor);\n        } else if (charToInsert && charToInsert.length > 0) {\n            if (selection && selection.length > 0) {\n                ({text, cursor} = this.handleSelectionDeletion(selection, text, cursor, deletions));\n            }\n            ({text, cursor} = this.handleCharacterInsert(charToInsert, text, cursor, highlights));\n        }\n        return {\n            text,\n            cursor,\n            updatedHighlights: highlights,\n            updatedDeleted: deletions\n        };\n    }\n\n    detectSelection(eventIndex) {\n        const currentEvent = this.logData[eventIndex];\n\n        if (currentEvent.event?.toLowerCase() === 'keydown' &&\n            (currentEvent.key === 'Backspace' || currentEvent.key === 'Delete')) {\n\n            const currentPos = currentEvent.rePosition;\n\n            for (let i = eventIndex + 1; i < this.logData.length; i++) {\n                const nextEvent = this.logData[i];\n\n                if (nextEvent.event?.toLowerCase() === 'keyup' &&\n                    nextEvent.key === currentEvent.key) {\n\n                    const nextPos = nextEvent.rePosition;\n\n                    // Calculate the difference in positions\n                    const positionDiff = Math.abs(currentPos - nextPos);\n\n                    if (positionDiff > 1) {\n                        return {\n                            start: Math.min(currentPos, nextPos),\n                            end: Math.max(currentPos, nextPos),\n                            length: positionDiff\n                        };\n                    } else if (positionDiff === 1) {\n                        if (currentEvent.key === 'Backspace') {\n                            return {\n                                start: nextPos,\n                                end: currentPos,\n                                length: 1\n                            };\n                        } else {\n                            return {\n                                start: currentPos,\n                                end: nextPos,\n                                length: 1\n                            };\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        return null;\n    }\n\n    handleSelectionDeletion(selection, text, cursor, deletions) {\n        const {start, end, length} = selection;\n\n        // Add each character in the selection to the deletions array\n        for (let i = start; i < end && i < text.length; i++) {\n            deletions.push({\n                index: start,\n                chars: text[i],\n                time: this.currentTime,\n                expiresAt: this.currentTime + 2000\n            });\n        }\n\n        text = text.substring(0, start) + text.substring(end);\n\n        this.shiftPastedCharsIndices(start, length);\n\n        cursor = start;\n\n        return {text, cursor};\n    }\n\n    // Handle Paste events to highlight pasted text\n    handlePasteInsert(pastedContent, text, cursor) {\n        const insertText = pastedContent || '';\n        text = text.substring(0, cursor) + insertText + text.substring(cursor);\n\n        // Mark characters as pasted for bold styling\n        if (insertText.trim() !== '') {\n            for (let i = 0; i < insertText.length; i++) {\n                if (!this.pastedChars) {\n                    this.pastedChars = [];\n                }\n                this.pastedChars.push({\n                    index: cursor + i,\n                    chars: insertText[i]\n                });\n            }\n        }\n\n        return {text, cursor: cursor + insertText.length};\n    }\n\n    // Adjusts pasted chars indices after deletion to maintain styling for pasted text\n    shiftPastedCharsIndices(startIndex, numDeleted) {\n        this.pastedChars = this.pastedChars.map(p => {\n            if (p.index >= startIndex + numDeleted) {\n                return {...p, index: p.index - numDeleted};\n            } else if (p.index >= startIndex && p.index < startIndex + numDeleted) {\n                // Remove pasted characters that were deleted\n                return null;\n            }\n            return p;\n        }).filter(p => p !== null);\n\n        if (this.aiChars) {\n            this.aiChars = this.aiChars.map(p => {\n                if (p.index >= startIndex + numDeleted) {\n                    return {...p, index: p.index - numDeleted};\n                } else if (p.index >= startIndex && p.index < startIndex + numDeleted) {\n                    return null;\n                }\n                return p;\n            }).filter(p => p !== null);\n        }\n    }\n\n    // Update state for modifier keys (Control, paste events)\n    updateModifierStates(key) {\n        if (key === 'Control') {\n            this.isControlKeyPressed = true;\n        } else if (key === 'Shift') {\n            this.isShiftKeyPressed = true;\n        } else if (key === 'Meta') {\n            this.isMetaKeyPressed = true;\n        } else if ((key === 'v' || key === 'V') && (this.isControlKeyPressed || this.isMetaKeyPressed)) {\n            this.isPasteEvent = true;\n        } else if (!['Control', 'Meta', 'Backspace', 'Delete', 'ArrowLeft', 'ArrowRight'].includes(key)) {\n            this.isControlKeyPressed = false;\n            this.isShiftKeyPressed = false;\n            this.isMetaKeyPressed = false;\n            this.isPasteEvent = false;\n        }\n    }\n\n    isCtrlBackspace(key, cursor) {\n        return key === 'Backspace' && this.isControlKeyPressed && cursor > 0;\n    }\n\n    isCtrlDelete(key, cursor, text) {\n        return key === 'Delete' && this.isControlKeyPressed && cursor < text.length;\n    }\n\n    isCtrlArrowMove(key) {\n        return this.isControlKeyPressed && (key === 'ArrowLeft' || key === 'ArrowRight');\n    }\n\n    isRegularBackspace(key, cursor) {\n        return key === 'Backspace' && !this.isPasteEvent && cursor > 0;\n    }\n\n    isRegularDelete(key, cursor, text) {\n        return key === 'Delete' && !this.isControlKeyPressed && cursor < text.length;\n    }\n\n    isRegularArrowMove(key) {\n        return !this.isControlKeyPressed && (key === 'ArrowLeft' || key === 'ArrowRight');\n    }\n\n    isArrowUp(key) {\n        return key === 'ArrowUp';\n    }\n\n    isArrowDown(key) {\n        return key === 'ArrowDown';\n    }\n\n    handleCtrlArrowMove(key, text, cursor) {\n        return key === 'ArrowLeft'\n            ? this.findPreviousWordBoundary(text, cursor)\n            : this.findNextWordBoundary(text, cursor);\n    }\n\n    handleBackspace(text, cursor, deletions) {\n        deletions.push({\n            index: cursor - 1,\n            chars: text[cursor - 1],\n            time: this.currentTime,\n            expiresAt: this.currentTime + 2000\n        });\n        this.shiftPastedCharsIndices(cursor - 1, 1);\n        return {\n            text: text.substring(0, cursor - 1) + text.substring(cursor),\n            cursor: cursor - 1\n        };\n    }\n\n    handleDelete(text, cursor, deletions) {\n        deletions.push({\n            index: cursor,\n            chars: text[cursor],\n            time: this.currentTime,\n            expiresAt: this.currentTime + 2000\n        });\n        this.shiftPastedCharsIndices(cursor, 1);\n        return {\n            text: text.substring(0, cursor) + text.substring(cursor + 1),\n            cursor\n        };\n    }\n\n    handleArrowMove(key, text, cursor) {\n        return key === 'ArrowLeft'\n            ? Math.max(0, cursor - 1)\n            : Math.min(text.length, cursor + 1);\n    }\n\n    handleCharacterInsert(charToInsert, text, cursor, highlights) {\n        text = text.substring(0, cursor) + charToInsert + text.substring(cursor);\n        // Shift pasted chars indices after the insertion point\n        if (this.pastedChars) {\n            this.pastedChars = this.pastedChars.map(p => {\n                return p.index >= cursor ? {...p, index: p.index + 1} : p;\n            });\n        }\n        if (this.aiChars) {\n            this.aiChars = this.aiChars.map(p => {\n                return p.index >= cursor ? {...p, index: p.index + 1} : p;\n            });\n        }\n        if (charToInsert.trim() !== '') {\n            highlights.push({\n                index: cursor,\n                chars: charToInsert,\n                time: this.currentTime,\n                expiresAt: this.currentTime + 1500\n            });\n        }\n        return {text, cursor: cursor + 1};\n    }\n\n    handleCtrlDelete(text, cursor, deletions) {\n        const wordEnd = this.findNextWordBoundary(text, cursor);\n        const wordToDelete = text.substring(cursor, wordEnd);\n        for (let i = 0; i < wordToDelete.length; i++) {\n            deletions.push({\n                index: cursor + i,\n                chars: wordToDelete[i],\n                time: this.currentTime,\n                expiresAt: this.currentTime + 2000\n            });\n        }\n        this.shiftPastedCharsIndices(cursor, wordToDelete.length);\n        return {\n            text: text.substring(0, cursor) + text.substring(wordEnd),\n            cursor\n        };\n    }\n\n    handleArrowUp(text, cursor) {\n        const lines = text.split('\\n');\n        const {lineIndex, col} = this.getLineAndColumn(text, cursor);\n        if (lineIndex > 0) {\n            const prevLine = lines[lineIndex - 1];\n            cursor = lines.slice(0, lineIndex - 1).join('\\n').length + 1 + Math.min(col, prevLine.length);\n        } else {\n            cursor = 0;\n        }\n        return cursor;\n    }\n\n    handleArrowDown(text, cursor) {\n        const lines = text.split('\\n');\n        const {lineIndex, col} = this.getLineAndColumn(text, cursor);\n        if (lineIndex < lines.length - 1) {\n            const nextLine = lines[lineIndex + 1];\n            cursor = lines.slice(0, lineIndex + 1).join('\\n').length + 1 + Math.min(col, nextLine.length);\n        } else {\n            cursor = text.length;\n        }\n        return cursor;\n    }\n\n    handleCtrlBackspace(text, cursor, deletions) {\n        let wordStart = cursor;\n        while (wordStart > 0 && text[wordStart - 1] === ' ') {\n            wordStart--;\n        }\n        while (wordStart > 0 && text[wordStart - 1] !== ' ') {\n            wordStart--;\n        }\n        const wordToDelete = text.substring(wordStart, cursor);\n        for (let i = 0; i < wordToDelete.length; i++) {\n            deletions.push({\n                index: wordStart + i,\n                chars: wordToDelete[i],\n                time: this.currentTime,\n                expiresAt: this.currentTime + 2000\n            });\n        }\n        this.shiftPastedCharsIndices(wordStart, wordToDelete.length);\n        return {text: text.substring(0, wordStart) + text.substring(cursor), cursor: wordStart};\n    }\n\n    // Finds the index of the next word boundary after the cursor position\n    findNextWordBoundary(text, cursor) {\n        if (!text || cursor >= text.length) {\n            return cursor;\n        }\n        if (text[cursor] === ' ') {\n            while (cursor < text.length && text[cursor] === ' ') {\n                 cursor++;\n            }\n        }\n        if (cursor >= text.length) {\n            let lastNonSpace = text.length - 1;\n            while (lastNonSpace >= 0 && text[lastNonSpace] === ' ') {\n                 lastNonSpace--;\n            }\n            return lastNonSpace + 1;\n        }\n        let wordEnd = cursor;\n        while (wordEnd < text.length && text[wordEnd] !== ' ') {\n             wordEnd++;\n         }\n        return wordEnd;\n    }\n\n    // Finds the index of the previous word boundary before the cursor position\n    findPreviousWordBoundary(text, cursor) {\n        if (cursor <= 0) {\n            return 0;\n        }\n        let pos = cursor - 1;\n        while (pos > 0 && (text[pos] === ' ' || text[pos] === '\\n')) {\n             pos--;\n        }\n        while (pos > 0 && text[pos - 1] !== ' ' && text[pos - 1] !== '\\n') {\n             pos--;\n        }\n\n        return pos;\n    }\n\n    skipToEnd() {\n        if (this.replayInProgress) {\n            this.replayInProgress = false;\n        }\n        let textOutput = \"\";\n        this.logData.forEach(event => {\n            if (event.event.toLowerCase() === 'keydown') {\n                textOutput = this.applyKey(event.key, textOutput);\n            }\n        });\n        this.outputElement.innerHTML = textOutput.slice(0, -1);\n        this.setScrubberVal(100);\n    }\n\n    // Used by the scrubber to skip to a certain percentage of data\n    skipToTime(percentage) {\n        const wasPlaying = this.replayInProgress;\n        this.stopReplay();\n\n        const targetTime = (this.totalDuration * percentage) / 100;\n        this.currentTime = targetTime;\n        this.currentEventIndex = 0;\n        this.text = '';\n        this.cursorPosition = 0;\n        this.highlightedChars = [];\n        this.deletedChars = [];\n        this.isControlKeyPressed = false;\n        this.isMetaKeyPressed = false;\n        this.isPasteEvent = false;\n        this.pastedChars = [];\n        this.currentPasteIndex = 0;\n        this.currentAiIndex = 0;\n        this.aiChars = [];\n        let text = '';\n        let cursor = 0;\n        let highlights = [];\n        let deletions = [];\n        let pasteIndex = 0;\n        let aiIndex = 0;\n\n        for (let i = 0; i < this.logData.length; i++) {\n            const event = this.logData[i];\n            if (event.normalizedTime && event.normalizedTime > targetTime) {\n                this.currentEventIndex = i;\n                break;\n            }\n            if (event.rePosition !== undefined && (this.currentEventIndex === 0 ||\n                event.event === 'mouseDown' || event.event === 'mouseUp')) {\n                cursor = Math.max(0, Math.min(event.rePosition, text.length));\n            }\n            if (event.event?.toLowerCase() === 'keydown') {\n                this.currentPasteIndex = pasteIndex;\n                if ((event.key === 'v' || event.key === 'V') && (this.isControlKeyPressed || this.isMetaKeyPressed)) {\n                    pasteIndex++;\n                }\n                ({text, cursor, updatedHighlights: highlights, updatedDeleted: deletions} =\n                    this.processKeydownEvent(event, text, cursor, highlights, deletions));\n            } else if (event.event === 'aiInsert') {\n                this.currentAiIndex = aiIndex;\n                ({text, cursor, updatedHighlights: highlights, updatedDeleted: deletions} =\n                    this.processAiInsertEvent(event, text, cursor, highlights, deletions));\n                aiIndex++;\n            }\n            this.currentEventIndex = i + 1;\n        }\n\n        this.currentPasteIndex = pasteIndex;\n        this.currentAiIndex = aiIndex;\n        this.text = text;\n        this.cursorPosition = cursor;\n        this.highlightedChars = highlights.filter(h => !h.expiresAt || h.expiresAt > targetTime);\n        this.deletedChars = deletions.filter(d => !d.expiresAt || d.expiresAt > targetTime);\n        this.updateDisplayText(this.text, this.cursorPosition, this.highlightedChars, this.deletedChars);\n        this.setScrubberVal(percentage);\n\n        if (wasPlaying) {\n            this.replayInProgress = true;\n            this.replayLog();\n        }\n    }\n\n    // Update display with text, cursor, highlights and deletions.\n    // eslint-disable-next-line complexity\n    updateDisplayText(text, cursorPosition, highlights, deletions) {\n        let html = '';\n        const highlightMap = {};\n        const deletionMap = {};\n        const pastedMap = {};\n        const aiMap = {};\n        const currentTime = this.currentTime;\n\n        highlights.forEach(h => {\n            let opacity = 1;\n            if (h.expiresAt && h.expiresAt - currentTime < 500) {\n                opacity = Math.max(0, (h.expiresAt - currentTime) / 500);\n            }\n            highlightMap[h.index] = {chars: h.chars, opacity};\n        });\n\n        deletions.forEach(d => {\n            let opacity = 0.5;\n            if (d.expiresAt && d.expiresAt - currentTime < 500) {\n                opacity = Math.max(0, ((d.expiresAt - currentTime) / 500) * 0.5);\n            }\n            deletionMap[d.index] = {chars: d.chars, opacity};\n        });\n\n        // Process pasted characters for bold styling\n        if (this.pastedChars) {\n            this.pastedChars.forEach(p => {\n                if (p.index < text.length) {\n                    pastedMap[p.index] = true;\n                }\n            });\n        }\n\n        // Process AI characters for styling\n        if (this.aiChars) {\n            this.aiChars.forEach(p => {\n                if (p.index < text.length) {\n                    aiMap[p.index] = true;\n                }\n            });\n        }\n\n        // Find if we have out-of-bounds deletions (from Control+Backspace)\n        const outOfRangeDeletions = deletions.filter(d => d.index >= text.length);\n        const textLines = text.split('\\n');\n        let currentPosition = 0;\n\n        for (let lineIndex = 0; lineIndex < textLines.length; lineIndex++) {\n            const line = textLines[lineIndex];\n            for (let i = 0; i < line.length; i++) {\n                if (currentPosition === cursorPosition) {\n                    html += '<span class=\"tiny_cursive-cursor\"></span>';\n                }\n                const char = line[i];\n                if (deletionMap[currentPosition]) {\n                    html += `<span class=\"tiny_cursive-deleted-char\" style=\"opacity:\n                        ${deletionMap[currentPosition].opacity};\">${deletionMap[currentPosition].chars}</span>`;\n                }\n                const isPasted = pastedMap[currentPosition];\n                const isAi = aiMap[currentPosition];\n                const isHighlighted = highlightMap[currentPosition] && char !== ' ';\n\n                if (isPasted && isHighlighted) {\n                    html += `<span class=\"tiny_cursive-pasted-char tiny_cursive-highlighted-char\" style=\"opacity:\n                        ${highlightMap[currentPosition].opacity};\">${char}</span>`;\n                } else if (isAi && isHighlighted) {\n                    html += `<span class=\"tiny_cursive-ai-char tiny_cursive-highlighted-char\" style=\"opacity:\n                        ${highlightMap[currentPosition].opacity};\">${char}</span>`;\n                } else if (isPasted) {\n                    html += `<span class=\"tiny_cursive-pasted-char\">${char === ' ' ? ' ' : this.escapeHtml(char)}</span>`;\n                } else if (isAi) {\n                    html += `<span class=\"tiny_cursive-ai-char\">${char === ' ' ? ' ' : this.escapeHtml(char)}</span>`;\n                } else if (isHighlighted) {\n                    html += `<span class=\"tiny_cursive-highlighted-char\" style=\"opacity:\n                        ${highlightMap[currentPosition].opacity};\">${char}</span>`;\n                } else {\n                    html += char === ' ' ? ' ' : this.escapeHtml(char);\n                }\n                currentPosition++;\n            }\n            if (currentPosition === cursorPosition) {\n                html += '<span class=\"tiny_cursive-cursor\"></span>';\n            }\n            if (lineIndex < textLines.length - 1) {\n                html += '<br>';\n                currentPosition++;\n            }\n        }\n\n        if (cursorPosition === text.length && !html.endsWith('<span class=\"tiny_cursive-cursor\"></span>')) {\n            html += '<span class=\"tiny_cursive-cursor\"></span>';\n        }\n\n        if (outOfRangeDeletions.length > 0) {\n            outOfRangeDeletions.sort((a, b) => a.index - b.index);\n            const cursorHTML = '<span class=\"tiny_cursive-cursor\"></span>';\n            const cursorPos = html.lastIndexOf(cursorHTML);\n            if (cursorPos !== -1) {\n                let deletedWordHTML = '<span class=\"tiny_cursive-deleted-char\" style=\"opacity: 0.5;\">';\n                outOfRangeDeletions.forEach(d => {\n                    deletedWordHTML += d.chars;\n                });\n                deletedWordHTML += '</span>';\n                html = html.substring(0, cursorPos) + deletedWordHTML + html.substring(cursorPos);\n            }\n        }\n\n        const wasScrolledToBottom = this.outputElement.scrollHeight -\n            this.outputElement.clientHeight <= this.outputElement.scrollTop + 1;\n        this.outputElement.innerHTML = html;\n\n        if (wasScrolledToBottom || this.isCursorBelowViewport()) {\n            this.outputElement.scrollTop = this.outputElement.scrollHeight;\n        }\n    }\n\n    // Check if cursor is below visible viewport\n    isCursorBelowViewport() {\n        const cursorElement = this.outputElement.querySelector('.tiny_cursive-cursor:last-of-type');\n        if (!cursorElement) {\n            return false;\n        }\n\n        const cursorRect = cursorElement.getBoundingClientRect();\n        const outputRect = this.outputElement.getBoundingClientRect();\n\n        return cursorRect.bottom > outputRect.bottom;\n    }\n\n    escapeHtml(unsafe) {\n        return unsafe\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#039;');\n    }\n\n    // Used in various places to add a keydown, backspace, etc. to the output\n    applyKey(key) {\n        switch (key) {\n            case 'Enter':\n                return '\\n';\n            case 'Backspace':\n            case 'Delete':\n            case 'ControlBackspace':\n                return '';\n            case ' ':\n                 return ' ';\n            default:\n                return !['Shift', 'Ctrl', 'Alt', 'ArrowDown', 'ArrowUp', 'Control', 'ArrowRight',\n                    'ArrowLeft', 'Meta', 'CapsLock', 'Tab', 'Escape', 'Delete', 'PageUp', 'PageDown',\n                    'Insert', 'Home', 'End', 'NumLock', 'AudioVolumeUp', 'AudioVolumeDown',\n                    'MediaPlayPause', 'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10',\n                    'F11', 'F12', 'PrintScreen', 'UnIdentified'].includes(key) ? key : '';\n        }\n    }\n}\n"],"names":["constructor","elementId","filePath","speed","loop","controllerId","replayInProgress","parseFloat","highlightedChars","deletedChars","cursorPosition","currentEventIndex","totalEvents","currentTime","totalDuration","usercomments","pasteTimestamps","isPasteEvent","isControlKeyPressed","isShiftKeyPressed","isMetaKeyPressed","text","pastedEvents","currentPasteIndex","pastedChars","aiEvents","currentAiIndex","aiChars","element","document","getElementById","Error","outputElement","loadJSON","then","data","status","processData","this","logData","length","identifyPasteEvents","constructController","startReplay","handleNoSubmission","catch","error","window","console","message","localStorage","getItem","Str","get_string","str","setItem","log","JSON","parse","comments","Array","isArray","stringify","payload","i","event","pastedContent","trim","push","aiContent","unixTimestamp","startTime","map","normalizedTime","html","Promise","all","templates","render","newElement","stopReplay","clearTimeout","replayTimeout","playButton","playSvg","createElement","src","M","util","image_url","querySelector","innerHTML","outerHTML","currentPosition","replayIntervalId","clearInterval","container","controlContainer","buildControllerUI","remove","topRow","classList","add","createPlayButton","appendChild","scrubberContainer","createScrubberContainer","timeDisplay","createTimeDisplay","bottomRow","speedContainer","createSpeedControls","pasteEventsToggle","createPasteEventsToggle","pasteEventsPanel","addEventListener","find","removeClass","addClass","scrubberElement","type","max","min","value","skipToTime","parseInt","textContent","speedLabel","speedGroup","forEach","speedBtn","dataset","querySelectorAll","btn","pasteEventsIcon","pasteIcon","pasteEventsText","pasteEventCount","className","style","marginLeft","chevronIcon","chevron","transition","createPasteEventsPanel","isHidden","display","transform","existingPanel","populatePasteEventsPanel","controlPressed","metaPressed","shiftPressed","pasteCount","toLowerCase","key","timestamp","index","time","formattedTime","formatTime","pastedText","panel","noEventsMessage","carouselContainer","navigationRow","counterDisplay","navButtons","prevButton","nextButton","disabled","contentContainer","createPasteEventDisplay","currentIndex","updateDisplay","opacity","pasteEvent","eventRow","headerRow","textContainer","timestampContainer","pastedTextContainer","playIcon","jumpToTimestamp","percentage","setScrubberVal","String","displayTime","Math","methodname","args","filepath","done","response","fail","ms","seconds","floor","remainingSeconds","toString","padStart","reset","pauseSvg","replayLog","cursor","updatedHighlights","updatedDeleted","undefined","rePosition","processKeydownEvent","processAiInsertEvent","filter","h","expiresAt","d","updateDisplayText","percentComplete","baseIncrement","incrementTime","setTimeout","getLineAndColumn","pos","before","substring","lineIndex","split","col","lastIndexOf","highlights","deletions","targetPosition","handleAiReplacement","currentCursor","insertText","aiWords","isMultiWord","wordStart","wordEnd","isNewLineInsertion","startsWith","endsWith","lineStart","lineEnd","lineText","words","start","end","bestMatch","score","wordCount","similarityScore","seqWords","j","positionScore","compareLength","k","ai","seq","calculateSimilarity","seqStart","seqEndPos","totalScore","closest","findClosestWord","aiWord","bestSimilarityMatch","bestSimilarityScore","word","similarity","wordLower","distance","abs","wordToReplace","chars","replacedLength","positionDiff","newCursor","p","justAddedIndices","Set","has","str1","str2","len1","len2","matrix","fill","cost","maxLen","minDistance","charToInsert","applyKey","updateModifierStates","selection","detectSelection","handleSelectionDeletion","handlePasteInsert","isCtrlBackspace","handleCtrlBackspace","isCtrlDelete","handleCtrlDelete","isCtrlArrowMove","handleCtrlArrowMove","isRegularBackspace","handleBackspace","isRegularDelete","handleDelete","isArrowUp","handleArrowUp","isArrowDown","handleArrowDown","isRegularArrowMove","handleArrowMove","handleCharacterInsert","eventIndex","currentEvent","currentPos","nextEvent","nextPos","shiftPastedCharsIndices","startIndex","numDeleted","includes","findPreviousWordBoundary","findNextWordBoundary","wordToDelete","lines","prevLine","slice","join","nextLine","lastNonSpace","skipToEnd","textOutput","wasPlaying","targetTime","pasteIndex","aiIndex","highlightMap","deletionMap","pastedMap","aiMap","outOfRangeDeletions","textLines","line","char","isPasted","isAi","isHighlighted","escapeHtml","sort","a","b","cursorHTML","cursorPos","deletedWordHTML","wasScrolledToBottom","scrollHeight","clientHeight","scrollTop","isCursorBelowViewport","cursorElement","cursorRect","getBoundingClientRect","outputRect","bottom","unsafe","replace"],"mappings":"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"}