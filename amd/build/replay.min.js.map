{"version":3,"file":"replay.min.js","sources":["../src/replay.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * @module     tiny_cursive/replay\r\n * @category TinyMCE Editor\r\n * @copyright  CTI <info@cursivetechnology.com>\r\n * @author kuldeep singh <mca.kuldeep.sekhon@gmail.com>\r\n */\r\n\r\nimport {call as fetchJson} from 'core/ajax';\r\nimport templates from 'core/templates';\r\nimport $ from 'jquery';\r\nimport * as Str from 'core/str';\r\n\r\nexport default class Replay {\r\n    constructor(elementId, filePath, speed = 1, loop = false, controllerId) {\r\n        // Initialize core properties\r\n        this.controllerId = controllerId || '';\r\n        this.replayInProgress = false;\r\n        this.speed = parseFloat(speed);\r\n        this.loop = loop;\r\n        this.highlightedChars = [];\r\n        this.deletedChars = [];\r\n        this.cursorPosition = 0;\r\n        this.currentEventIndex = 0;\r\n        this.totalEvents = 0;\r\n        this.currentTime = 0;\r\n        this.totalDuration = 0;\r\n        this.usercomments = [];\r\n        this.pasteTimestamps = [];\r\n        this.isPasteEvent = false;\r\n        this.isControlKeyPressed = false;\r\n        this.isShiftKeyPressed = false;\r\n        this.isMetaKeyPressed = false;\r\n        this.text = '';\r\n        this.pastedEvents = [];\r\n        this.currentPasteIndex = 0;\r\n        this.pastedChars = [];\r\n        this.aiEvents = [];\r\n        this.currentAiIndex = 0;\r\n        this.aiChars = [];\r\n        this.undoTimestamps = [];\r\n        this.undoChars = [];\r\n\r\n        const element = document.getElementById(elementId);\r\n        if (!element) {\r\n            throw new Error(`Element with id '${elementId}' not found`);\r\n        }\r\n        this.outputElement = element;\r\n\r\n        // Load JSON data and initialize replay\r\n        this.loadJSON(filePath).then(data => {\r\n            if (data.status) {\r\n                this.processData(data);\r\n                this.totalEvents = this.logData.length;\r\n                this.identifyPasteEvents();\r\n                this.identifyUndoEvents();\r\n                if (this.controllerId && this.logData) {\r\n                    this.constructController(this.controllerId);\r\n                }\r\n                this.startReplay();\r\n            } else {\r\n                this.handleNoSubmission();\r\n            }\r\n            return data;\r\n        }).catch(error => {\r\n            this.handleNoSubmission();\r\n            window.console.error('Error loading JSON file:', error.message);\r\n        });\r\n        if (!localStorage.getItem('nopasteevent') || !localStorage.getItem('pasteEvent')) {\r\n            Str.get_string('nopasteevent', 'tiny_cursive').then(str => {\r\n                localStorage.setItem('nopasteevent', str);\r\n                return str;\r\n            }).catch(error => window.console.log(error));\r\n            Str.get_string('pasteEvent', 'tiny_cursive').then(str => {\r\n                localStorage.setItem('pasteEvent', str);\r\n                return str;\r\n            }).catch(error => window.console.log(error));\r\n        }\r\n    }\r\n\r\n    // Process JSON data and normalize timestamps\r\n    processData(data) {\r\n        this.logData = JSON.parse(data.data);\r\n        if (data.comments) {\r\n            this.usercomments = Array.isArray(JSON.parse(data.comments)) ? JSON.parse(data.comments) : [];\r\n        }\r\n        if ('data' in this.logData) {\r\n            this.logData = this.logData.data;\r\n        }\r\n        if ('payload' in this.logData) {\r\n            this.logData = this.logData.payload;\r\n        }\r\n        for (let i = 0; i < this.logData.length; i++) {\r\n            const event = this.logData[i];\r\n            if (event.event === 'Paste') {\r\n                if (typeof event.pastedContent === 'string' && event.pastedContent.trim() !== '') {\r\n                    this.pastedEvents.push(event.pastedContent);\r\n                }\r\n            }\r\n            if (event.event === 'aiInsert' && event.aiContent) {\r\n                this.aiEvents.push(event.aiContent);\r\n            }\r\n        }\r\n        if (this.logData.length > 0 && this.logData[0].unixTimestamp) {\r\n            const startTime = this.logData[0].unixTimestamp;\r\n            this.logData = this.logData.map(event => ({\r\n                ...event,\r\n                normalizedTime: event.unixTimestamp - startTime\r\n            }));\r\n            this.totalDuration = this.logData[this.logData.length - 1].normalizedTime;\r\n        }\r\n    }\r\n\r\n    async handleNoSubmission() {\r\n        try {\r\n            const [html, str] = await Promise.all([\r\n                templates.render('tiny_cursive/no_submission'),\r\n                Str.get_string('warningpayload', 'tiny_cursive')\r\n            ]);\r\n            const newElement = $(html).text(str);\r\n            return $('.tiny_cursive').html(newElement);\r\n        } catch (error) {\r\n            window.console.error(error);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Stop the replay and update play button icon\r\n    stopReplay() {\r\n        if (this.replayInProgress) {\r\n            clearTimeout(this.replayTimeout);\r\n            this.replayInProgress = false;\r\n            if (this.playButton) {\r\n                const playSvg = document.createElement('img');\r\n                playSvg.src = M.util.image_url('playicon', 'tiny_cursive');\r\n                this.playButton.querySelector('.play-icon').innerHTML = playSvg.outerHTML;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Build the replay control UI (play button, scrubber, speed controls)\r\n    constructController(controllerId) {\r\n        this.replayInProgress = false;\r\n        this.currentPosition = 0;\r\n        this.speed = 1;\r\n        if (this.replayIntervalId) {\r\n            clearInterval(this.replayIntervalId);\r\n            this.replayIntervalId = null;\r\n        }\r\n\r\n        const container = document.getElementById(controllerId);\r\n        if (!container) {\r\n            window.console.error('Container not found with ID:', controllerId);\r\n            return;\r\n        }\r\n\r\n        const controlContainer = container.querySelector('.tiny_cursive_replay_control');\r\n        if (!controlContainer) {\r\n            window.console.error('Replay control container not found in:', controllerId);\r\n            return;\r\n        }\r\n        controlContainer.innerHTML = '<span class=\"tiny_cursive_loading_spinner\"></span>';\r\n\r\n        this.buildControllerUI(controlContainer, container);\r\n        controlContainer.querySelector('.tiny_cursive_loading_spinner')?.remove();\r\n    }\r\n\r\n    buildControllerUI(controlContainer, container) {\r\n        const topRow = document.createElement('div');\r\n        topRow.classList.add('tiny_cursive_top_row');\r\n\r\n        this.playButton = this.createPlayButton();\r\n        topRow.appendChild(this.playButton);\r\n\r\n        const scrubberContainer = this.createScrubberContainer();\r\n        topRow.appendChild(scrubberContainer);\r\n\r\n        this.timeDisplay = this.createTimeDisplay();\r\n        topRow.appendChild(this.timeDisplay);\r\n\r\n        const bottomRow = document.createElement('div');\r\n        bottomRow.classList.add('tiny_cursive_bottom_row');\r\n\r\n        const speedContainer = this.createSpeedControls();\r\n        bottomRow.appendChild(speedContainer);\r\n\r\n        const pasteEventsToggle = this.createPasteEventsToggle(container);\r\n        bottomRow.appendChild(pasteEventsToggle);\r\n\r\n        controlContainer.appendChild(topRow);\r\n        controlContainer.appendChild(bottomRow);\r\n        container.appendChild(this.pasteEventsPanel);\r\n    }\r\n\r\n    createPlayButton() {\r\n        const playButton = document.createElement('button');\r\n        playButton.classList.add('tiny_cursive_play_button');\r\n        const playSvg = document.createElement('i');\r\n        playButton.innerHTML = `<span class=\"play-icon\">${playSvg.outerHTML}</span>`;\r\n        playButton.addEventListener('click', () => {\r\n            if (this.replayInProgress) {\r\n                this.stopReplay();\r\n            } else {\r\n                this.startReplay(false);\r\n            }\r\n            $('.tiny_cursive-nav-tab').find('.active').removeClass('active');\r\n            $('a[id^=\"rep\"]').addClass('active');\r\n        });\r\n        return playButton;\r\n    }\r\n\r\n    createScrubberContainer() {\r\n        const scrubberContainer = document.createElement('div');\r\n        scrubberContainer.classList.add('tiny_cursive_scrubber_container');\r\n        this.scrubberElement = document.createElement('input');\r\n        this.scrubberElement.classList.add('tiny_cursive_timeline_scrubber', 'timeline-scrubber');\r\n        this.scrubberElement.type = 'range';\r\n        this.scrubberElement.max = '100';\r\n        this.scrubberElement.min = '0';\r\n        this.scrubberElement.value = '0';\r\n        this.scrubberElement.addEventListener('input', () => {\r\n            this.skipToTime(parseInt(this.scrubberElement.value, 10));\r\n        });\r\n        scrubberContainer.appendChild(this.scrubberElement);\r\n        return scrubberContainer;\r\n    }\r\n\r\n    createTimeDisplay() {\r\n        const timeDisplay = document.createElement('div');\r\n        timeDisplay.classList.add('tiny_cursive_time_display');\r\n        timeDisplay.textContent = '00:00 / 00:00';\r\n        return timeDisplay;\r\n    }\r\n\r\n    createSpeedControls() {\r\n        const speedContainer = document.createElement('div');\r\n        speedContainer.classList.add('tiny_cursive_speed_controls', 'speed-controls');\r\n        const speedLabel = document.createElement('span');\r\n        speedLabel.classList.add('tiny_cursive_speed_label');\r\n        speedLabel.textContent = 'Speed: ';\r\n        speedContainer.appendChild(speedLabel);\r\n\r\n        const speedGroup = document.createElement('div');\r\n        speedGroup.classList.add('tiny_cursive_speed_group');\r\n        [1, 1.5, 2, 5, 10].forEach(speed => {\r\n            const speedBtn = document.createElement('button');\r\n            speedBtn.textContent = `${speed}x`;\r\n            speedBtn.classList.add('tiny_cursive_speed_btn', 'speed-btn');\r\n            if (parseFloat(speed) === this.speed) {\r\n                speedBtn.classList.add('active');\r\n            }\r\n            speedBtn.dataset.speed = speed;\r\n            speedBtn.addEventListener('click', () => {\r\n                document.querySelectorAll('.tiny_cursive_speed_btn').forEach(btn => btn.classList.remove('active'));\r\n                speedBtn.classList.add('active');\r\n                this.speed = parseFloat(speedBtn.dataset.speed);\r\n                if (this.replayInProgress) {\r\n                    this.stopReplay();\r\n                    this.startReplay(false);\r\n                }\r\n            });\r\n            speedGroup.appendChild(speedBtn);\r\n        });\r\n        speedContainer.appendChild(speedGroup);\r\n        return speedContainer;\r\n    }\r\n\r\n    createPasteEventsToggle(container) {\r\n        const pasteEventsToggle = document.createElement('div');\r\n        pasteEventsToggle.classList.add('tiny_cursive_paste_events_toggle', 'paste-events-toggle');\r\n\r\n        const pasteEventsIcon = document.createElement('span');\r\n        const pasteIcon = document.createElement('img');\r\n        pasteIcon.src = M.util.image_url('pasteicon', 'tiny_cursive');\r\n        pasteEventsIcon.innerHTML = pasteIcon.outerHTML;\r\n        pasteEventsIcon.classList.add('tiny_cursive_paste_events_icon');\r\n\r\n        const pasteEventsText = document.createElement('span');\r\n        pasteEventsText.textContent = localStorage.getItem('pasteEvent');\r\n\r\n        this.pasteEventCount = document.createElement('span');\r\n        this.pasteEventCount.textContent = `(${this.pasteTimestamps.length})`;\r\n        this.pasteEventCount.className = 'paste-event-count';\r\n        this.pasteEventCount.style.marginLeft = '2px';\r\n\r\n        const chevronIcon = document.createElement('span');\r\n        const chevron = document.createElement('i');\r\n        chevron.className = 'fa fa-chevron-down';\r\n        chevronIcon.innerHTML = chevron.outerHTML;\r\n        chevronIcon.style.marginLeft = '5px';\r\n        chevronIcon.style.transition = 'transform 0.3s ease';\r\n\r\n        pasteEventsToggle.appendChild(pasteEventsIcon);\r\n        pasteEventsToggle.appendChild(pasteEventsText);\r\n        pasteEventsToggle.appendChild(this.pasteEventCount);\r\n        pasteEventsToggle.appendChild(chevronIcon);\r\n\r\n        this.pasteEventsPanel = this.createPasteEventsPanel(container);\r\n        pasteEventsToggle.addEventListener('click', () => {\r\n            const isHidden = this.pasteEventsPanel.style.display === 'none';\r\n            this.pasteEventsPanel.style.display = isHidden ? 'block' : 'none';\r\n            chevronIcon.style.transform = isHidden ? 'rotate(180deg)' : 'rotate(0deg)';\r\n        });\r\n\r\n        return pasteEventsToggle;\r\n    }\r\n\r\n    createPasteEventsPanel(container) {\r\n        const existingPanel = container.querySelector('.paste-events-panel');\r\n        if (existingPanel) {\r\n            existingPanel.remove();\r\n        }\r\n        const pasteEventsPanel = document.createElement('div');\r\n        pasteEventsPanel.classList.add('tiny_cursive_paste_events_panel', 'paste-events-panel');\r\n        pasteEventsPanel.style.display = 'none';\r\n        this.populatePasteEventsPanel(pasteEventsPanel);\r\n        return pasteEventsPanel;\r\n    }\r\n\r\n    // Detect Ctrl+V paste events and sync with user comments\r\n    identifyPasteEvents() {\r\n        this.pasteTimestamps = [];\r\n        let controlPressed = false;\r\n        let metaPressed = false;\r\n        /* eslint-disable no-unused-vars */\r\n        let shiftPressed = false;\r\n        let pasteCount = 0;\r\n\r\n        for (let i = 0; i < this.logData.length; i++) {\r\n            const event = this.logData[i];\r\n            if (event.event?.toLowerCase() === 'keydown') {\r\n                if (event.key === 'Control') {\r\n                    controlPressed = true;\r\n                } else if (event.key === 'Meta') {\r\n                    metaPressed = true;\r\n                } else if (event.key === 'Shift') {\r\n                    shiftPressed = true;\r\n                } else if ((event.key === 'v' || event.key === 'V') && (controlPressed || metaPressed)) {\r\n                    if (this.pastedEvents[pasteCount]) {\r\n                        const timestamp = event.normalizedTime || 0;\r\n                        this.pasteTimestamps.push({\r\n                            index: pasteCount,\r\n                            time: timestamp,\r\n                            formattedTime: this.formatTime(timestamp),\r\n                            pastedText: this.pastedEvents[pasteCount],\r\n                            timestamp\r\n                        });\r\n                    }\r\n                    pasteCount++;\r\n                    controlPressed = false;\r\n                    shiftPressed = false;\r\n                    metaPressed = false;\r\n                } else {\r\n                    controlPressed = false;\r\n                    shiftPressed = false;\r\n                    metaPressed = false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.pasteEventsPanel) {\r\n            this.populatePasteEventsPanel(this.pasteEventsPanel);\r\n        }\r\n    }\r\n\r\n    identifyUndoEvents() {\r\n        this.undoTimestamps = [];\r\n        let controlPressed = false;\r\n        let metaPressed = false;\r\n        let undoCount = 0;\r\n\r\n        for (let i = 0; i < this.logData.length; i++) {\r\n            const event = this.logData[i];\r\n            if (event.event?.toLowerCase() === 'keydown') {\r\n                if (event.key === 'Control') {\r\n                    controlPressed = true;\r\n                } else if (event.key === 'Meta') {\r\n                    metaPressed = true;\r\n                } else if ((event.key === 'z' || event.key === 'Z') && (controlPressed || metaPressed)) {\r\n                    const timestamp = event.normalizedTime || 0;\r\n                    this.undoTimestamps.push({\r\n                        index: undoCount,\r\n                        time: timestamp,\r\n                        formattedTime: this.formatTime(timestamp),\r\n                        timestamp\r\n                    });\r\n                    undoCount++;\r\n                    controlPressed = false;\r\n                    metaPressed = false;\r\n                } else {\r\n                    controlPressed = false;\r\n                    metaPressed = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Populate the paste events panel with navigation\r\n    populatePasteEventsPanel(panel) {\r\n        panel.innerHTML = '';\r\n        panel.classList.add('tiny_cursive_event_panel');\r\n\r\n        if (!this.pasteTimestamps.length) {\r\n            const noEventsMessage = document.createElement('div');\r\n            noEventsMessage.className = 'no-paste-events-message p-3';\r\n            noEventsMessage.textContent = localStorage.getItem('nopasteevent');\r\n            panel.appendChild(noEventsMessage);\r\n            return;\r\n        }\r\n\r\n        const carouselContainer = document.createElement('div');\r\n        carouselContainer.classList.add('tiny_cursive_paste_events_carousel', 'paste-events-carousel');\r\n\r\n        const navigationRow = document.createElement('div');\r\n        navigationRow.classList.add('paste-events-navigation', 'tiny_cursive_navigation_row');\r\n\r\n        const counterDisplay = document.createElement('div');\r\n        counterDisplay.classList.add('paste-events-counter', 'tiny_cursive_counter_display');\r\n        counterDisplay.textContent = 'Paste Events';\r\n\r\n        const navButtons = document.createElement('div');\r\n        navButtons.classList.add('tiny_cursive_nav_buttons');\r\n        const prevButton = document.createElement('button');\r\n        prevButton.classList.add('paste-event-prev-btn', 'tiny_cursive_nav_button');\r\n        prevButton.innerHTML = '<i class=\"fa fa-chevron-left\"></i>';\r\n\r\n        const nextButton = document.createElement('button');\r\n        nextButton.classList.add('paste-event-next-btn', 'tiny_cursive_nav_button');\r\n        nextButton.innerHTML = '<i class=\"fa fa-chevron-right\"></i>';\r\n        nextButton.disabled = this.pasteTimestamps.length <= 1;\r\n\r\n        navButtons.appendChild(prevButton);\r\n        navButtons.appendChild(nextButton);\r\n        navigationRow.appendChild(counterDisplay);\r\n        navigationRow.appendChild(navButtons);\r\n\r\n        const contentContainer = document.createElement('div');\r\n        contentContainer.className = 'paste-events-content tiny_cursive_content_container';\r\n        contentContainer.appendChild(this.createPasteEventDisplay(this.pasteTimestamps[0]));\r\n\r\n        carouselContainer.appendChild(navigationRow);\r\n        carouselContainer.appendChild(contentContainer);\r\n        panel.appendChild(carouselContainer);\r\n\r\n        let currentIndex = 0;\r\n        const updateDisplay = () => {\r\n            contentContainer.innerHTML = '';\r\n            contentContainer.appendChild(this.createPasteEventDisplay(this.pasteTimestamps[currentIndex]));\r\n            counterDisplay.textContent = 'Paste Events';\r\n            prevButton.disabled = currentIndex === 0;\r\n            prevButton.style.opacity = currentIndex === 0 ? '0.5' : '1';\r\n            nextButton.disabled = currentIndex === this.pasteTimestamps.length - 1;\r\n            nextButton.style.opacity = currentIndex === this.pasteTimestamps.length - 1 ? '0.5' : '1';\r\n        };\r\n\r\n        prevButton.addEventListener('click', () => {\r\n            if (currentIndex > 0) {\r\n                currentIndex--;\r\n                updateDisplay();\r\n            }\r\n        });\r\n\r\n        nextButton.addEventListener('click', () => {\r\n            if (currentIndex < this.pasteTimestamps.length - 1) {\r\n                currentIndex++;\r\n                updateDisplay();\r\n            }\r\n        });\r\n    }\r\n\r\n    createPasteEventDisplay(pasteEvent) {\r\n        const eventRow = document.createElement('div');\r\n        eventRow.className = 'tiny_cursive_event_row';\r\n\r\n        const headerRow = document.createElement('div');\r\n        headerRow.className = 'tiny_cursive_header_row';\r\n\r\n        const textContainer = document.createElement('div');\r\n        textContainer.className = 'tiny_cursive_text_container';\r\n\r\n        const timestampContainer = document.createElement('div');\r\n        timestampContainer.className = 'paste-event-timestamp tiny_cursive_paste_event_timestamp';\r\n        timestampContainer.textContent = pasteEvent.formattedTime;\r\n\r\n        const pastedTextContainer = document.createElement('div');\r\n        pastedTextContainer.className = 'paste-event-text tiny_cursive_pasted_text_container';\r\n        pastedTextContainer.textContent = pasteEvent.pastedText;\r\n\r\n        textContainer.appendChild(timestampContainer);\r\n        textContainer.appendChild(pastedTextContainer);\r\n\r\n        const playButton = document.createElement('button');\r\n        playButton.className = 'paste-event-play-btn tiny_cursive_seekplay_button';\r\n        const playIcon = document.createElement('img');\r\n        playIcon.src = M.util.image_url('seekplayicon', 'tiny_cursive');\r\n        playButton.innerHTML = playIcon.outerHTML;\r\n        playButton.addEventListener('click', () => this.jumpToTimestamp(pasteEvent.timestamp));\r\n\r\n        headerRow.appendChild(textContainer);\r\n        headerRow.appendChild(playButton);\r\n        eventRow.appendChild(headerRow);\r\n\r\n        return eventRow;\r\n    }\r\n\r\n    // Jump to a specific timestamp in the replay\r\n    jumpToTimestamp(timestamp) {\r\n        const percentage = this.totalDuration > 0 ? (timestamp / this.totalDuration) * 100 : 0;\r\n        this.skipToTime(percentage);\r\n        if (!this.replayInProgress) {\r\n            this.startReplay(false);\r\n        }\r\n    }\r\n\r\n    setScrubberVal(value) {\r\n        if (this.scrubberElement) {\r\n            this.scrubberElement.value = String(value);\r\n            if (this.timeDisplay) {\r\n                const displayTime = Math.min(this.currentTime, this.totalDuration);\r\n                this.timeDisplay.textContent = `${this.formatTime(displayTime)} / ${this.formatTime(this.totalDuration)}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    loadJSON(filePath) {\r\n        return fetchJson([{\r\n            methodname: 'cursive_get_reply_json',\r\n            args: {filepath: filePath}\r\n        }])[0].done(response => response).fail(error => {\r\n            throw new Error(`Error loading JSON file: ${error.message}`);\r\n        });\r\n    }\r\n\r\n    formatTime(ms) {\r\n        const seconds = Math.floor(ms / 1000);\r\n        const minutes = Math.floor(seconds / 60);\r\n        const remainingSeconds = seconds % 60;\r\n        return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;\r\n    }\r\n\r\n    // Start or restart the replay\r\n    startReplay(reset = true) {\r\n        if (this.replayInProgress) {\r\n            clearTimeout(this.replayTimeout);\r\n        }\r\n        const atEnd = (this.totalDuration > 0 && this.currentTime >= this.totalDuration) ||\r\n            (this.currentEventIndex >= this.totalEvents);\r\n        if (atEnd && !reset) {\r\n            reset = true;\r\n        }\r\n        this.replayInProgress = true;\r\n        if (reset) {\r\n            this.outputElement.innerHTML = '';\r\n            this.text = '';\r\n            this.cursorPosition = 0;\r\n            this.currentEventIndex = 0;\r\n            this.currentTime = 0;\r\n            this.highlightedChars = [];\r\n            this.deletedChars = [];\r\n            this.isControlKeyPressed = false;\r\n            this.isMetaKeyPressed = false;\r\n            this.currentPasteIndex = 0;\r\n            this.pastedChars = [];\r\n            this.currentAiIndex = 0;\r\n            this.aiChars = [];\r\n        }\r\n        if (this.playButton) {\r\n            const pauseSvg = document.createElement('i');\r\n            pauseSvg.className = 'fa fa-pause';\r\n            this.playButton.querySelector('.play-icon').innerHTML = pauseSvg.outerHTML;\r\n        }\r\n        this.replayLog();\r\n    }\r\n\r\n    // Process events in sequence to simulate typing\r\n    replayLog() {\r\n        if (!this.replayInProgress) {\r\n            this.updateDisplayText(this.text, this.cursorPosition, [], []);\r\n            return;\r\n        }\r\n\r\n        while (this.currentEventIndex < this.logData.length) {\r\n            const event = this.logData[this.currentEventIndex];\r\n            if (event.normalizedTime && event.normalizedTime > this.currentTime) {\r\n                break;\r\n            }\r\n\r\n            let text = this.text || '';\r\n            let cursor = this.cursorPosition;\r\n            let updatedHighlights = [...this.highlightedChars];\r\n            let updatedDeleted = [...this.deletedChars];\r\n\r\n            if (event.rePosition !== undefined && (this.currentEventIndex === 0 ||\r\n                event.event === 'mouseDown' || event.event === 'mouseUp')) {\r\n                cursor = Math.max(0, Math.min(event.rePosition, text.length));\r\n            }\r\n\r\n            if (event.event?.toLowerCase() === 'keydown') {\r\n                ({text, cursor, updatedHighlights, updatedDeleted} =\r\n                    this.processKeydownEvent(event, text, cursor, updatedHighlights, updatedDeleted));\r\n            } else if (event.event === 'aiInsert') {\r\n                ({text, cursor, updatedHighlights, updatedDeleted} =\r\n                    this.processAiInsertEvent(event, text, cursor, updatedHighlights, updatedDeleted));\r\n               }\r\n\r\n            this.text = text;\r\n            this.cursorPosition = cursor;\r\n            this.highlightedChars = updatedHighlights.filter(h => !h.expiresAt || h.expiresAt > this.currentTime);\r\n            this.deletedChars = updatedDeleted.filter(d => !d.expiresAt || d.expiresAt > this.currentTime);\r\n\r\n            this.currentEventIndex++;\r\n        }\r\n\r\n        this.updateDisplayText(this.text, this.cursorPosition, this.highlightedChars, this.deletedChars);\r\n        if (this.totalDuration > 0) {\r\n            const percentComplete = Math.min((this.currentTime / this.totalDuration) * 100, 100);\r\n            this.setScrubberVal(percentComplete);\r\n        }\r\n\r\n        if (this.replayInProgress) {\r\n            const baseIncrement = 100;\r\n            const incrementTime = baseIncrement / this.speed;\r\n            this.currentTime += baseIncrement;\r\n            if (this.currentEventIndex >= this.totalEvents) {\r\n                if (this.loop) {\r\n                    this.startReplay(true);\r\n                } else {\r\n                    this.stopReplay();\r\n                    this.updateDisplayText(this.text, this.cursorPosition, [], []);\r\n                }\r\n            } else {\r\n                this.replayTimeout = setTimeout(() => this.replayLog(), incrementTime);\r\n            }\r\n        }\r\n    }\r\n\r\n    getLineAndColumn(text, pos) {\r\n        const before = text.substring(0, pos);\r\n        const lineIndex = before.split('\\n').length - 1;\r\n        const col = before.length - before.lastIndexOf('\\n') - 1;\r\n        return {lineIndex, col};\r\n    }\r\n\r\n    processAiInsertEvent(event, text, cursor, highlights, deletions) {\r\n        if (this.aiEvents && this.currentAiIndex < this.aiEvents.length) {\r\n            const aiContent = this.aiEvents[this.currentAiIndex];\r\n            // Use event.rePosition which points to where the word to replace is\r\n            const targetPosition = event.rePosition;\r\n\r\n            ({text, cursor} = this.handleAiReplacement(aiContent, text, targetPosition, cursor, deletions));\r\n            this.currentAiIndex++;\r\n        }\r\n        return {\r\n            text,\r\n            cursor,\r\n            updatedHighlights: highlights,\r\n            updatedDeleted: deletions\r\n        };\r\n    }\r\n\r\n    handleAiReplacement(aiContent, text, targetPosition, currentCursor, deletions) {\r\n        const insertText = aiContent || '';\r\n        const aiWords = insertText.trim().split(/\\s+/);\r\n        const isMultiWord = aiWords.length > 1;\r\n        const isNewLineInsertion = insertText.startsWith('\\n') || insertText.endsWith('\\n');\r\n\r\n        const {wordStart, wordEnd} = this.findWordToReplace(\r\n            text,\r\n            targetPosition,\r\n            currentCursor,\r\n            aiWords,\r\n            isMultiWord,\r\n            isNewLineInsertion\r\n        );\r\n\r\n        const wordToReplace = text.substring(wordStart, wordEnd);\r\n\r\n        // Mark replaced characters as deleted\r\n        this.markCharsAsDeleted(wordToReplace, wordStart, deletions);\r\n\r\n        // Perform the replacement\r\n        const replacedLength = wordToReplace.length;\r\n        text = text.substring(0, wordStart) + insertText + text.substring(wordEnd);\r\n        const positionDiff = insertText.length - replacedLength;\r\n\r\n        // Calculate new cursor position\r\n        const newCursor = this.calculateNewCursorPosition(\r\n            currentCursor,\r\n            targetPosition,\r\n            wordStart,\r\n            wordEnd,\r\n            insertText,\r\n            isNewLineInsertion\r\n        );\r\n\r\n        // Update character tracking arrays\r\n        this.updateCharacterIndices(wordStart, wordEnd, positionDiff, insertText);\r\n\r\n        return {text, cursor: newCursor};\r\n    }\r\n\r\n    findWordToReplace(text, targetPosition, currentCursor, aiWords, isMultiWord, isNewLineInsertion) {\r\n        if (isNewLineInsertion) {\r\n            return {wordStart: currentCursor, wordEnd: currentCursor};\r\n        }\r\n\r\n        const {lineStart, lineEnd} = this.findLineRange(text, targetPosition);\r\n        const lineText = text.substring(lineStart, lineEnd);\r\n        const words = this.extractWordsFromLine(lineText, lineStart);\r\n\r\n        if (words.length === 0) {\r\n            return {wordStart: currentCursor, wordEnd: currentCursor};\r\n        }\r\n\r\n        if (isMultiWord) {\r\n            return this.findMultiWordMatch(words, aiWords, targetPosition);\r\n        } else {\r\n            return this.findSingleWordMatch(words, aiWords[0], targetPosition);\r\n        }\r\n    }\r\n\r\n    findLineRange(text, targetPosition) {\r\n        let lineStart = 0;\r\n        for (let i = targetPosition - 1; i >= 0; i--) {\r\n            if (text[i] === '\\n') {\r\n                lineStart = i + 1;\r\n                break;\r\n            }\r\n        }\r\n\r\n        let lineEnd = text.length;\r\n        for (let i = targetPosition; i < text.length; i++) {\r\n            if (text[i] === '\\n') {\r\n                lineEnd = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return {lineStart, lineEnd};\r\n    }\r\n\r\n    extractWordsFromLine(lineText, lineStart) {\r\n        const words = [];\r\n        let pos = 0;\r\n\r\n        while (pos < lineText.length) {\r\n            // Skip spaces\r\n            while (pos < lineText.length && lineText[pos] === ' ') {\r\n                pos++;\r\n            }\r\n            if (pos >= lineText.length) {\r\n                break;\r\n            }\r\n\r\n            // Extract word\r\n            const start = pos;\r\n            while (pos < lineText.length && lineText[pos] !== ' ') {\r\n                pos++;\r\n            }\r\n\r\n            if (pos > start) {\r\n                words.push({\r\n                    text: lineText.substring(start, pos),\r\n                    start: lineStart + start,\r\n                    end: lineStart + pos\r\n                });\r\n            }\r\n        }\r\n\r\n        return words;\r\n    }\r\n\r\n    findMultiWordMatch(words, aiWords, targetPosition) {\r\n        let bestMatch = {start: -1, end: -1, score: -1, wordCount: 0, similarityScore: 0};\r\n\r\n        for (let i = 0; i < words.length; i++) {\r\n            const matchResult = this.evaluateMultiWordSequence(words, aiWords, i, targetPosition);\r\n\r\n            if (matchResult.totalScore > bestMatch.score ||\r\n                (matchResult.totalScore === bestMatch.score &&\r\n                 matchResult.similarityScore > bestMatch.similarityScore)) {\r\n                bestMatch = matchResult;\r\n            }\r\n        }\r\n\r\n        if (bestMatch.score > 10) {\r\n            return {wordStart: bestMatch.start, wordEnd: bestMatch.end};\r\n        } else {\r\n            const closest = this.findClosestWord(words, targetPosition);\r\n            return {wordStart: closest.start, wordEnd: closest.end};\r\n        }\r\n    }\r\n\r\n    evaluateMultiWordSequence(words, aiWords, startIndex, targetPosition) {\r\n        const seqWords = [];\r\n        for (let j = 0; j < aiWords.length && startIndex + j < words.length; j++) {\r\n            seqWords.push(words[startIndex + j]);\r\n        }\r\n\r\n        if (seqWords.length === 0) {\r\n            return {start: -1, end: -1, score: -1, wordCount: 0, similarityScore: 0};\r\n        }\r\n\r\n        const similarityScore = this.calculateSequenceSimilarity(aiWords, seqWords);\r\n        const positionScore = this.calculatePositionScore(seqWords, targetPosition);\r\n        const totalScore = similarityScore + positionScore + seqWords.length;\r\n\r\n        return {\r\n            start: seqWords[0].start,\r\n            end: seqWords[seqWords.length - 1].end,\r\n            score: totalScore,\r\n            wordCount: seqWords.length,\r\n            similarityScore: similarityScore\r\n        };\r\n    }\r\n\r\n    calculateSequenceSimilarity(aiWords, seqWords) {\r\n        let similarityScore = 0;\r\n        const compareLength = Math.min(seqWords.length, aiWords.length);\r\n\r\n        for (let k = 0; k < compareLength; k++) {\r\n            const ai = aiWords[k].toLowerCase();\r\n            const seq = seqWords[k].text.toLowerCase();\r\n\r\n            if (ai === seq) {\r\n                similarityScore += 10;\r\n            } else {\r\n                const similarity = this.calculateSimilarity(ai, seq);\r\n                similarityScore += similarity * 10;\r\n            }\r\n        }\r\n\r\n        return similarityScore;\r\n    }\r\n\r\n    calculatePositionScore(seqWords, targetPosition) {\r\n        let positionScore = 0;\r\n        const seqStart = seqWords[0].start;\r\n        const seqEndPos = seqWords[seqWords.length - 1].end;\r\n\r\n        if (targetPosition >= seqStart && targetPosition <= seqEndPos) {\r\n            positionScore += 10;\r\n            if (targetPosition >= seqWords[0].start && targetPosition <= seqWords[0].end) {\r\n                positionScore += 5;\r\n            }\r\n        }\r\n\r\n        return positionScore;\r\n    }\r\n\r\n    findSingleWordMatch(words, aiWord, targetPosition) {\r\n        const aiWordLower = aiWord.toLowerCase();\r\n        const bestSimilarityMatch = this.findBestSimilarityMatch(words, aiWordLower);\r\n\r\n        if (bestSimilarityMatch.score > 0.5) {\r\n            return {wordStart: bestSimilarityMatch.word.start, wordEnd: bestSimilarityMatch.word.end};\r\n        }\r\n\r\n        const bestPositionMatch = this.findBestPositionMatch(words, aiWordLower, targetPosition);\r\n\r\n        if (bestPositionMatch.word) {\r\n            return {wordStart: bestPositionMatch.word.start, wordEnd: bestPositionMatch.word.end};\r\n        }\r\n\r\n        // Fallback to position-based word boundary\r\n        return this.findWordBoundaryAtPosition(words[0].start, words[words.length - 1].end,\r\n                                                targetPosition, this.text);\r\n    }\r\n\r\n    findBestSimilarityMatch(words, aiWordLower) {\r\n        let bestMatch = {word: null, score: 0};\r\n\r\n        for (const word of words) {\r\n            let similarity = this.calculateSimilarity(aiWordLower, word.text.toLowerCase());\r\n            const wordLower = word.text.toLowerCase();\r\n\r\n            // Penalize short prefix matches\r\n            if (wordLower.length < aiWordLower.length * 0.5 && aiWordLower.startsWith(wordLower)) {\r\n                similarity = similarity * 0.3;\r\n            }\r\n\r\n            if (similarity > bestMatch.score) {\r\n                bestMatch = {word, score: similarity};\r\n            }\r\n        }\r\n\r\n        return bestMatch;\r\n    }\r\n\r\n    findBestPositionMatch(words, aiWordLower, targetPosition) {\r\n        let bestMatch = {word: null, score: -1};\r\n\r\n        for (const word of words) {\r\n            let score = this.calculateWordScore(word, aiWordLower, targetPosition);\r\n\r\n            if (score > bestMatch.score) {\r\n                bestMatch = {word, score};\r\n            }\r\n        }\r\n\r\n        return bestMatch;\r\n    }\r\n\r\n    calculateWordScore(word, aiWordLower, targetPosition) {\r\n        let score = 0;\r\n\r\n        // Position score\r\n        if (targetPosition >= word.start && targetPosition <= word.end) {\r\n            score += 30;\r\n        } else {\r\n            const distance = Math.min(\r\n                Math.abs(targetPosition - word.start),\r\n                Math.abs(targetPosition - word.end)\r\n            );\r\n            score += Math.max(0, 20 - distance);\r\n        }\r\n\r\n        // Similarity score with penalty\r\n        let similarity = this.calculateSimilarity(aiWordLower, word.text.toLowerCase());\r\n        const wordLower = word.text.toLowerCase();\r\n        if (wordLower.length < aiWordLower.length * 0.5 && aiWordLower.startsWith(wordLower)) {\r\n            similarity = similarity * 0.3;\r\n        }\r\n        score += similarity * 10;\r\n\r\n        return score;\r\n    }\r\n\r\n    findWordBoundaryAtPosition(lineStart, lineEnd, targetPosition, text) {\r\n        let wordStart = targetPosition;\r\n        while (wordStart > lineStart && text[wordStart - 1] !== ' ' && text[wordStart - 1] !== '\\n') {\r\n            wordStart--;\r\n        }\r\n        let wordEnd = targetPosition;\r\n        while (wordEnd < lineEnd && text[wordEnd] !== ' ' && text[wordEnd] !== '\\n') {\r\n            wordEnd++;\r\n        }\r\n        return {wordStart, wordEnd};\r\n    }\r\n\r\n    markCharsAsDeleted(wordToReplace, wordStart, deletions) {\r\n        if (wordToReplace.length > 0) {\r\n            for (let i = 0; i < wordToReplace.length; i++) {\r\n                deletions.push({\r\n                    index: wordStart + i,\r\n                    chars: wordToReplace[i],\r\n                    time: this.currentTime,\r\n                    expiresAt: this.currentTime + 2000\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    calculateNewCursorPosition(currentCursor, targetPosition, wordStart, wordEnd, insertText, isNewLineInsertion) {\r\n        if (isNewLineInsertion) {\r\n            return wordStart + insertText.length;\r\n        }\r\n\r\n        if (targetPosition >= wordStart && targetPosition <= wordEnd) {\r\n            return wordStart + insertText.length;\r\n        }\r\n\r\n        const positionDiff = insertText.length - (wordEnd - wordStart);\r\n\r\n        if (currentCursor >= wordEnd) {\r\n            return currentCursor + positionDiff;\r\n        } else if (currentCursor > wordStart && currentCursor < wordEnd) {\r\n            return wordStart + insertText.length;\r\n        }\r\n\r\n        return currentCursor;\r\n    }\r\n\r\n    updateCharacterIndices(wordStart, wordEnd, positionDiff, insertText) {\r\n        // Update pasted character indices\r\n        this.updatePastedCharIndices(wordStart, wordEnd, positionDiff);\r\n\r\n        // Mark characters as AI-inserted\r\n        this.markCharsAsAiInserted(wordStart, insertText);\r\n\r\n        // Update AI character indices\r\n        this.updateAiCharIndices(wordStart, wordEnd, positionDiff, insertText);\r\n    }\r\n\r\n    updatePastedCharIndices(wordStart, wordEnd, positionDiff) {\r\n        if (this.pastedChars) {\r\n            this.pastedChars = this.pastedChars.map(p => {\r\n                if (p.index >= wordEnd) {\r\n                    return {...p, index: p.index + positionDiff};\r\n                } else if (p.index >= wordStart && p.index < wordEnd) {\r\n                    return null;\r\n                }\r\n                return p;\r\n            }).filter(p => p !== null);\r\n        }\r\n    }\r\n\r\n    markCharsAsAiInserted(wordStart, insertText) {\r\n        if (!this.aiChars) {\r\n            this.aiChars = [];\r\n        }\r\n\r\n        if (insertText.trim() !== '') {\r\n            for (let i = 0; i < insertText.length; i++) {\r\n                this.aiChars.push({\r\n                    index: wordStart + i,\r\n                    chars: insertText[i]\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    updateAiCharIndices(wordStart, wordEnd, positionDiff, insertText) {\r\n        const justAddedIndices = new Set();\r\n        for (let i = 0; i < insertText.length; i++) {\r\n            justAddedIndices.add(wordStart + i);\r\n        }\r\n\r\n        this.aiChars = this.aiChars.map(p => {\r\n            if (!justAddedIndices.has(p.index)) {\r\n                if (p.index >= wordEnd) {\r\n                    return {...p, index: p.index + positionDiff};\r\n                } else if (p.index >= wordStart && p.index < wordEnd) {\r\n                    return null;\r\n                }\r\n            }\r\n            return p;\r\n        }).filter(p => p !== null);\r\n    }\r\n\r\n    // Calculate similarity between two strings\r\n    calculateSimilarity(str1, str2) {\r\n        if (str1 === str2) {\r\n            return 1;\r\n        }\r\n        if (str1.length === 0 || str2.length === 0) {\r\n            return 0;\r\n        }\r\n\r\n        // Check if one string is a prefix of the other\r\n        if (str1.startsWith(str2) || str2.startsWith(str1)) {\r\n            return 0.8;\r\n        }\r\n\r\n        // Levenshtein distance\r\n        const len1 = str1.length;\r\n        const len2 = str2.length;\r\n        const matrix = Array(len2 + 1).fill(null).map(() => Array(len1 + 1).fill(0));\r\n\r\n        for (let i = 0; i <= len1; i++) {\r\n            matrix[0][i] = i;\r\n        }\r\n        for (let j = 0; j <= len2; j++) {\r\n            matrix[j][0] = j;\r\n        }\r\n\r\n        for (let j = 1; j <= len2; j++) {\r\n            for (let i = 1; i <= len1; i++) {\r\n                const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;\r\n                matrix[j][i] = Math.min(\r\n                    matrix[j][i - 1] + 1,\r\n                    matrix[j - 1][i] + 1,\r\n                    matrix[j - 1][i - 1] + cost\r\n                );\r\n            }\r\n        }\r\n\r\n        const maxLen = Math.max(len1, len2);\r\n        return 1 - (matrix[len2][len1] / maxLen);\r\n    }\r\n\r\n    // Find the word closest to a target position\r\n    findClosestWord(words, targetPosition) {\r\n        if (words.length === 0) {\r\n            return {start: targetPosition, end: targetPosition};\r\n        }\r\n\r\n        let closest = words[0];\r\n        let minDistance = Math.min(\r\n            Math.abs(targetPosition - words[0].start),\r\n            Math.abs(targetPosition - words[0].end)\r\n        );\r\n\r\n        for (const word of words) {\r\n            if (targetPosition >= word.start && targetPosition <= word.end) {\r\n                return word;\r\n            }\r\n\r\n            const distance = Math.min(\r\n                Math.abs(targetPosition - word.start),\r\n                Math.abs(targetPosition - word.end)\r\n            );\r\n\r\n            if (distance < minDistance) {\r\n                minDistance = distance;\r\n                closest = word;\r\n            }\r\n        }\r\n\r\n        return closest;\r\n    }\r\n\r\n    // Handle keydown events (e.g., typing, backspace, Ctrl+V)\r\n    processKeydownEvent(event, text, cursor, highlights, deletions) {\r\n        const key = event.key;\r\n        const charToInsert = this.applyKey(key);\r\n\r\n        // Handle copy operation (Ctrl+C)\r\n        if (this.isCopyOperation(key)) {\r\n            return {text, cursor, updatedHighlights: highlights, updatedDeleted: deletions};\r\n        }\r\n\r\n        // Handle undo operation (Ctrl+Z)\r\n        if (this.isUndoOperation(key)) {\r\n            return this.handleUndoOperation(event, text, cursor, highlights, deletions);\r\n        }\r\n\r\n        // Detect selection for current event\r\n        const currentEventIndex = this.currentEventIndex;\r\n        const selection = this.detectSelection(currentEventIndex);\r\n\r\n        // Handle paste operation (Ctrl+V)\r\n        if (this.isPasteOperation(key, event)) {\r\n            return this.handlePasteOperation(event, selection, text, cursor, highlights, deletions);\r\n        }\r\n\r\n        // Update modifier key states\r\n        this.updateModifierStates(key);\r\n\r\n        // Handle selection deletion with Backspace/Delete\r\n        if (this.isSelectionDeletion(key, selection)) {\r\n            ({text, cursor} = this.handleSelectionDeletion(selection, text, cursor, deletions));\r\n            return {text, cursor, updatedHighlights: highlights, updatedDeleted: deletions};\r\n        }\r\n\r\n        // Process various key operations\r\n        return this.processKeyOperation(key, charToInsert, text, cursor, highlights, deletions, selection);\r\n    }\r\n\r\n    isCopyOperation(key) {\r\n        return (key === 'c' || key === 'C') && (this.isControlKeyPressed || this.isMetaKeyPressed);\r\n    }\r\n\r\n    isUndoOperation(key) {\r\n        return (key === 'z' || key === 'Z') && (this.isControlKeyPressed || this.isMetaKeyPressed);\r\n    }\r\n\r\n    handleUndoOperation(event, text, cursor, highlights, deletions) {\r\n        const nextEventIndex = this.currentEventIndex + 1;\r\n        if (nextEventIndex < this.logData.length) {\r\n            const nextEvent = this.logData[nextEventIndex];\r\n\r\n            if (nextEvent.event === 'keyUp' && (nextEvent.key === 'z' || nextEvent.key === 'Z')) {\r\n                const newPosition = nextEvent.rePosition;\r\n                if (newPosition < cursor && text.length > 0) {\r\n                    const textBeforeUndo = text;\r\n                    text = text.substring(0, newPosition) + text.substring(cursor);\r\n                    cursor = newPosition;\r\n\r\n                    // Mark as deleted for visual effect\r\n                    for (let i = 0; i < textBeforeUndo.length && i < cursor; i++) {\r\n                        deletions.push({\r\n                            index: newPosition,\r\n                            chars: textBeforeUndo[i],\r\n                            time: this.currentTime,\r\n                            expiresAt: this.currentTime + 2000\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.isControlKeyPressed = false;\r\n        this.isMetaKeyPressed = false;\r\n\r\n        return {text, cursor, updatedHighlights: highlights, updatedDeleted: deletions};\r\n    }\r\n\r\n    isPasteOperation(key, event) {\r\n        if ((key === 'v' || key === 'V') && (this.isControlKeyPressed || this.isMetaKeyPressed)) {\r\n            return (event.pastedContent && event.pastedContent.trim() !== '') ||\r\n                   (this.pastedEvents && this.currentPasteIndex < this.pastedEvents.length);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    handlePasteOperation(event, selection, text, cursor, highlights, deletions) {\r\n        const pastedContent = event.pastedContent || this.pastedEvents[this.currentPasteIndex];\r\n\r\n        if (selection) {\r\n            ({text, cursor} = this.handleSelectionDeletion(selection, text, cursor, deletions));\r\n        }\r\n\r\n        ({text, cursor} = this.handlePasteInsert(pastedContent, text, cursor));\r\n        this.currentPasteIndex++;\r\n        this.resetModifierStates();\r\n        this.isPasteEvent = false;\r\n\r\n        return {text, cursor, updatedHighlights: highlights, updatedDeleted: deletions};\r\n    }\r\n\r\n    resetModifierStates() {\r\n        this.isControlKeyPressed = false;\r\n        this.isShiftKeyPressed = false;\r\n        this.isMetaKeyPressed = false;\r\n    }\r\n\r\n    isSelectionDeletion(key, selection) {\r\n        return (key === 'Backspace' || key === 'Delete') && selection && selection.length > 1;\r\n    }\r\n\r\n    processKeyOperation(key, charToInsert, text, cursor, highlights, deletions, selection) {\r\n        if (this.isCtrlBackspace(key, cursor)) {\r\n            ({text, cursor} = this.handleCtrlBackspace(text, cursor, deletions));\r\n        } else if (this.isCtrlDelete(key, cursor, text)) {\r\n            ({text} = this.handleCtrlDelete(text, cursor, deletions));\r\n        } else if (this.isCtrlArrowMove(key)) {\r\n            cursor = this.handleCtrlArrowMove(key, text, cursor);\r\n        } else if (this.isRegularBackspace(key, cursor)) {\r\n            ({text, cursor} = this.handleBackspace(text, cursor, deletions));\r\n        } else if (this.isRegularDelete(key, cursor, text)) {\r\n            ({text} = this.handleDelete(text, cursor, deletions));\r\n        } else if (this.isArrowUp(key)) {\r\n            cursor = this.handleArrowUp(text, cursor);\r\n        } else if (this.isArrowDown(key)) {\r\n            cursor = this.handleArrowDown(text, cursor);\r\n        } else if (this.isRegularArrowMove(key)) {\r\n            cursor = this.handleArrowMove(key, text, cursor);\r\n        } else if (charToInsert && charToInsert.length > 0) {\r\n            if (selection && selection.length > 0) {\r\n                ({text, cursor} = this.handleSelectionDeletion(selection, text, cursor, deletions));\r\n            }\r\n            ({text, cursor} = this.handleCharacterInsert(charToInsert, text, cursor, highlights));\r\n        }\r\n\r\n        return {text, cursor, updatedHighlights: highlights, updatedDeleted: deletions};\r\n    }\r\n\r\n    detectSelection(eventIndex) {\r\n        const currentEvent = this.logData[eventIndex];\r\n\r\n        if (currentEvent.event?.toLowerCase() === 'keydown' &&\r\n            (currentEvent.key === 'Backspace' || currentEvent.key === 'Delete')) {\r\n\r\n            const currentPos = currentEvent.rePosition;\r\n            return this.processDetection(currentPos, currentEvent, eventIndex);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    processDetection(currentPos, currentEvent, eventIndex) {\r\n        for (let i = eventIndex + 1; i < this.logData.length; i++) {\r\n            const nextEvent = this.logData[i];\r\n\r\n            if (nextEvent.event?.toLowerCase() === 'keyup' &&\r\n                nextEvent.key === currentEvent.key) {\r\n\r\n                const nextPos = nextEvent.rePosition;\r\n\r\n                // Calculate the difference in positions\r\n                const positionDiff = Math.abs(currentPos - nextPos);\r\n\r\n                if (positionDiff > 1) {\r\n                    return {\r\n                        start: Math.min(currentPos, nextPos),\r\n                        end: Math.max(currentPos, nextPos),\r\n                        length: positionDiff\r\n                    };\r\n                } else if (positionDiff === 1) {\r\n                    if (currentEvent.key === 'Backspace') {\r\n                        return {\r\n                            start: nextPos,\r\n                            end: currentPos,\r\n                            length: 1\r\n                        };\r\n                    } else {\r\n                        return {\r\n                            start: currentPos,\r\n                            end: nextPos,\r\n                            length: 1\r\n                        };\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    handleSelectionDeletion(selection, text, cursor, deletions) {\r\n        const {start, end, length} = selection;\r\n\r\n        // Add each character in the selection to the deletions array\r\n        for (let i = start; i < end && i < text.length; i++) {\r\n            deletions.push({\r\n                index: start,\r\n                chars: text[i],\r\n                time: this.currentTime,\r\n                expiresAt: this.currentTime + 2000\r\n            });\r\n        }\r\n\r\n        text = text.substring(0, start) + text.substring(end);\r\n\r\n        this.shiftPastedCharsIndices(start, length);\r\n\r\n        cursor = start;\r\n\r\n        return {text, cursor};\r\n    }\r\n\r\n    // Handle Paste events to highlight pasted text\r\n    handlePasteInsert(pastedContent, text, cursor) {\r\n        const insertText = pastedContent || '';\r\n        text = text.substring(0, cursor) + insertText + text.substring(cursor);\r\n\r\n        // Mark characters as pasted for bold styling\r\n        if (insertText.trim() !== '') {\r\n            for (let i = 0; i < insertText.length; i++) {\r\n                if (!this.pastedChars) {\r\n                    this.pastedChars = [];\r\n                }\r\n                this.pastedChars.push({\r\n                    index: cursor + i,\r\n                    chars: insertText[i]\r\n                });\r\n            }\r\n        }\r\n\r\n        return {text, cursor: cursor + insertText.length};\r\n    }\r\n\r\n    // Adjusts pasted chars indices after deletion to maintain styling for pasted text\r\n    shiftPastedCharsIndices(startIndex, numDeleted) {\r\n        this.pastedChars = this.pastedChars.map(p => {\r\n            if (p.index >= startIndex + numDeleted) {\r\n                return {...p, index: p.index - numDeleted};\r\n            } else if (p.index >= startIndex && p.index < startIndex + numDeleted) {\r\n                // Remove pasted characters that were deleted\r\n                return null;\r\n            }\r\n            return p;\r\n        }).filter(p => p !== null);\r\n\r\n        if (this.aiChars) {\r\n            this.aiChars = this.aiChars.map(p => {\r\n                if (p.index >= startIndex + numDeleted) {\r\n                    return {...p, index: p.index - numDeleted};\r\n                } else if (p.index >= startIndex && p.index < startIndex + numDeleted) {\r\n                    return null;\r\n                }\r\n                return p;\r\n            }).filter(p => p !== null);\r\n        }\r\n    }\r\n\r\n    // Update state for modifier keys (Control, paste events)\r\n    updateModifierStates(key) {\r\n        if (key === 'Control') {\r\n            this.isControlKeyPressed = true;\r\n        } else if (key === 'Shift') {\r\n            this.isShiftKeyPressed = true;\r\n        } else if (key === 'Meta') {\r\n            this.isMetaKeyPressed = true;\r\n        } else if ((key === 'v' || key === 'V') && (this.isControlKeyPressed || this.isMetaKeyPressed)) {\r\n            this.isPasteEvent = true;\r\n        } else if (!['Control', 'Meta', 'Backspace', 'Delete', 'ArrowLeft', 'ArrowRight'].includes(key)) {\r\n            this.isControlKeyPressed = false;\r\n            this.isShiftKeyPressed = false;\r\n            this.isMetaKeyPressed = false;\r\n            this.isPasteEvent = false;\r\n        }\r\n    }\r\n\r\n    isCtrlBackspace(key, cursor) {\r\n        return key === 'Backspace' && this.isControlKeyPressed && cursor > 0;\r\n    }\r\n\r\n    isCtrlDelete(key, cursor, text) {\r\n        return key === 'Delete' && this.isControlKeyPressed && cursor < text.length;\r\n    }\r\n\r\n    isCtrlArrowMove(key) {\r\n        return this.isControlKeyPressed && (key === 'ArrowLeft' || key === 'ArrowRight');\r\n    }\r\n\r\n    isRegularBackspace(key, cursor) {\r\n        return key === 'Backspace' && !this.isPasteEvent && cursor > 0;\r\n    }\r\n\r\n    isRegularDelete(key, cursor, text) {\r\n        return key === 'Delete' && !this.isControlKeyPressed && cursor < text.length;\r\n    }\r\n\r\n    isRegularArrowMove(key) {\r\n        return !this.isControlKeyPressed && (key === 'ArrowLeft' || key === 'ArrowRight');\r\n    }\r\n\r\n    isArrowUp(key) {\r\n        return key === 'ArrowUp';\r\n    }\r\n\r\n    isArrowDown(key) {\r\n        return key === 'ArrowDown';\r\n    }\r\n\r\n    handleCtrlArrowMove(key, text, cursor) {\r\n        return key === 'ArrowLeft'\r\n            ? this.findPreviousWordBoundary(text, cursor)\r\n            : this.findNextWordBoundary(text, cursor);\r\n    }\r\n\r\n    handleBackspace(text, cursor, deletions) {\r\n        deletions.push({\r\n            index: cursor - 1,\r\n            chars: text[cursor - 1],\r\n            time: this.currentTime,\r\n            expiresAt: this.currentTime + 2000\r\n        });\r\n        this.shiftPastedCharsIndices(cursor - 1, 1);\r\n        return {\r\n            text: text.substring(0, cursor - 1) + text.substring(cursor),\r\n            cursor: cursor - 1\r\n        };\r\n    }\r\n\r\n    handleDelete(text, cursor, deletions) {\r\n        deletions.push({\r\n            index: cursor,\r\n            chars: text[cursor],\r\n            time: this.currentTime,\r\n            expiresAt: this.currentTime + 2000\r\n        });\r\n        this.shiftPastedCharsIndices(cursor, 1);\r\n        return {\r\n            text: text.substring(0, cursor) + text.substring(cursor + 1),\r\n            cursor\r\n        };\r\n    }\r\n\r\n    handleArrowMove(key, text, cursor) {\r\n        return key === 'ArrowLeft'\r\n            ? Math.max(0, cursor - 1)\r\n            : Math.min(text.length, cursor + 1);\r\n    }\r\n\r\n    handleCharacterInsert(charToInsert, text, cursor, highlights) {\r\n        text = text.substring(0, cursor) + charToInsert + text.substring(cursor);\r\n        // Shift pasted chars indices after the insertion point\r\n        if (this.pastedChars) {\r\n            this.pastedChars = this.pastedChars.map(p => {\r\n                return p.index >= cursor ? {...p, index: p.index + 1} : p;\r\n            });\r\n        }\r\n        if (this.aiChars) {\r\n            this.aiChars = this.aiChars.map(p => {\r\n                return p.index >= cursor ? {...p, index: p.index + 1} : p;\r\n            });\r\n        }\r\n        if (charToInsert.trim() !== '') {\r\n            highlights.push({\r\n                index: cursor,\r\n                chars: charToInsert,\r\n                time: this.currentTime,\r\n                expiresAt: this.currentTime + 1500\r\n            });\r\n        }\r\n        return {text, cursor: cursor + 1};\r\n    }\r\n\r\n    handleCtrlDelete(text, cursor, deletions) {\r\n        const wordEnd = this.findNextWordBoundary(text, cursor);\r\n        const wordToDelete = text.substring(cursor, wordEnd);\r\n        for (let i = 0; i < wordToDelete.length; i++) {\r\n            deletions.push({\r\n                index: cursor + i,\r\n                chars: wordToDelete[i],\r\n                time: this.currentTime,\r\n                expiresAt: this.currentTime + 2000\r\n            });\r\n        }\r\n        this.shiftPastedCharsIndices(cursor, wordToDelete.length);\r\n        return {\r\n            text: text.substring(0, cursor) + text.substring(wordEnd),\r\n            cursor\r\n        };\r\n    }\r\n\r\n    handleArrowUp(text, cursor) {\r\n        const lines = text.split('\\n');\r\n        const {lineIndex, col} = this.getLineAndColumn(text, cursor);\r\n        if (lineIndex > 0) {\r\n            const prevLine = lines[lineIndex - 1];\r\n            cursor = lines.slice(0, lineIndex - 1).join('\\n').length + 1 + Math.min(col, prevLine.length);\r\n        } else {\r\n            cursor = 0;\r\n        }\r\n        return cursor;\r\n    }\r\n\r\n    handleArrowDown(text, cursor) {\r\n        const lines = text.split('\\n');\r\n        const {lineIndex, col} = this.getLineAndColumn(text, cursor);\r\n        if (lineIndex < lines.length - 1) {\r\n            const nextLine = lines[lineIndex + 1];\r\n            cursor = lines.slice(0, lineIndex + 1).join('\\n').length + 1 + Math.min(col, nextLine.length);\r\n        } else {\r\n            cursor = text.length;\r\n        }\r\n        return cursor;\r\n    }\r\n\r\n    handleCtrlBackspace(text, cursor, deletions) {\r\n        let wordStart = cursor;\r\n        while (wordStart > 0 && text[wordStart - 1] === ' ') {\r\n            wordStart--;\r\n        }\r\n        while (wordStart > 0 && text[wordStart - 1] !== ' ') {\r\n            wordStart--;\r\n        }\r\n        const wordToDelete = text.substring(wordStart, cursor);\r\n        for (let i = 0; i < wordToDelete.length; i++) {\r\n            deletions.push({\r\n                index: wordStart + i,\r\n                chars: wordToDelete[i],\r\n                time: this.currentTime,\r\n                expiresAt: this.currentTime + 2000\r\n            });\r\n        }\r\n        this.shiftPastedCharsIndices(wordStart, wordToDelete.length);\r\n        return {text: text.substring(0, wordStart) + text.substring(cursor), cursor: wordStart};\r\n    }\r\n\r\n    // Finds the index of the next word boundary after the cursor position\r\n    findNextWordBoundary(text, cursor) {\r\n        if (!text || cursor >= text.length) {\r\n            return cursor;\r\n        }\r\n        if (text[cursor] === ' ') {\r\n            while (cursor < text.length && text[cursor] === ' ') {\r\n                 cursor++;\r\n            }\r\n        }\r\n        if (cursor >= text.length) {\r\n            let lastNonSpace = text.length - 1;\r\n            while (lastNonSpace >= 0 && text[lastNonSpace] === ' ') {\r\n                 lastNonSpace--;\r\n            }\r\n            return lastNonSpace + 1;\r\n        }\r\n        let wordEnd = cursor;\r\n        while (wordEnd < text.length && text[wordEnd] !== ' ') {\r\n             wordEnd++;\r\n         }\r\n        return wordEnd;\r\n    }\r\n\r\n    // Finds the index of the previous word boundary before the cursor position\r\n    findPreviousWordBoundary(text, cursor) {\r\n        if (cursor <= 0) {\r\n            return 0;\r\n        }\r\n        let pos = cursor - 1;\r\n        while (pos > 0 && (text[pos] === ' ' || text[pos] === '\\n')) {\r\n             pos--;\r\n        }\r\n        while (pos > 0 && text[pos - 1] !== ' ' && text[pos - 1] !== '\\n') {\r\n             pos--;\r\n        }\r\n\r\n        return pos;\r\n    }\r\n\r\n    skipToEnd() {\r\n        if (this.replayInProgress) {\r\n            this.replayInProgress = false;\r\n        }\r\n        let textOutput = \"\";\r\n        this.logData.forEach(event => {\r\n            if (event.event.toLowerCase() === 'keydown') {\r\n                textOutput = this.applyKey(event.key, textOutput);\r\n            }\r\n        });\r\n        this.outputElement.innerHTML = textOutput.slice(0, -1);\r\n        this.setScrubberVal(100);\r\n    }\r\n\r\n    // Used by the scrubber to skip to a certain percentage of data\r\n    skipToTime(percentage) {\r\n        const wasPlaying = this.replayInProgress;\r\n        this.stopReplay();\r\n\r\n        const targetTime = (this.totalDuration * percentage) / 100;\r\n        this.currentTime = targetTime;\r\n        this.currentEventIndex = 0;\r\n        this.text = '';\r\n        this.cursorPosition = 0;\r\n        this.highlightedChars = [];\r\n        this.deletedChars = [];\r\n        this.isControlKeyPressed = false;\r\n        this.isMetaKeyPressed = false;\r\n        this.isPasteEvent = false;\r\n        this.pastedChars = [];\r\n        this.currentPasteIndex = 0;\r\n        this.currentAiIndex = 0;\r\n        this.aiChars = [];\r\n        let text = '';\r\n        let cursor = 0;\r\n        let highlights = [];\r\n        let deletions = [];\r\n        let pasteIndex = 0;\r\n        let aiIndex = 0;\r\n\r\n        for (let i = 0; i < this.logData.length; i++) {\r\n            const event = this.logData[i];\r\n            if (event.normalizedTime && event.normalizedTime > targetTime) {\r\n                this.currentEventIndex = i;\r\n                break;\r\n            }\r\n            if (event.rePosition !== undefined && (this.currentEventIndex === 0 ||\r\n                event.event === 'mouseDown' || event.event === 'mouseUp')) {\r\n                cursor = Math.max(0, Math.min(event.rePosition, text.length));\r\n            }\r\n            if (event.event?.toLowerCase() === 'keydown') {\r\n                this.currentPasteIndex = pasteIndex;\r\n                if ((event.key === 'v' || event.key === 'V') && (this.isControlKeyPressed || this.isMetaKeyPressed)) {\r\n                    pasteIndex++;\r\n                }\r\n                ({text, cursor, updatedHighlights: highlights, updatedDeleted: deletions} =\r\n                    this.processKeydownEvent(event, text, cursor, highlights, deletions));\r\n            } else if (event.event === 'aiInsert') {\r\n                this.currentAiIndex = aiIndex;\r\n                ({text, cursor, updatedHighlights: highlights, updatedDeleted: deletions} =\r\n                    this.processAiInsertEvent(event, text, cursor, highlights, deletions));\r\n                aiIndex++;\r\n            }\r\n            this.currentEventIndex = i + 1;\r\n        }\r\n\r\n        this.currentPasteIndex = pasteIndex;\r\n        this.currentAiIndex = aiIndex;\r\n        this.text = text;\r\n        this.cursorPosition = cursor;\r\n        this.highlightedChars = highlights.filter(h => !h.expiresAt || h.expiresAt > targetTime);\r\n        this.deletedChars = deletions.filter(d => !d.expiresAt || d.expiresAt > targetTime);\r\n        this.updateDisplayText(this.text, this.cursorPosition, this.highlightedChars, this.deletedChars);\r\n        this.setScrubberVal(percentage);\r\n\r\n        if (wasPlaying) {\r\n            this.replayInProgress = true;\r\n            this.replayLog();\r\n        }\r\n    }\r\n\r\n    // Update display with text, cursor, highlights and deletions.\r\n    // eslint-disable-next-line complexity\r\n    updateDisplayText(text, cursorPosition, highlights, deletions) {\r\n        let html = '';\r\n        const highlightMap = {};\r\n        const deletionMap = {};\r\n        const pastedMap = {};\r\n        const aiMap = {};\r\n        const currentTime = this.currentTime;\r\n\r\n        highlights.forEach(h => {\r\n            let opacity = 1;\r\n            if (h.expiresAt && h.expiresAt - currentTime < 500) {\r\n                opacity = Math.max(0, (h.expiresAt - currentTime) / 500);\r\n            }\r\n            highlightMap[h.index] = {chars: h.chars, opacity};\r\n        });\r\n\r\n        deletions.forEach(d => {\r\n            let opacity = 0.5;\r\n            if (d.expiresAt && d.expiresAt - currentTime < 500) {\r\n                opacity = Math.max(0, ((d.expiresAt - currentTime) / 500) * 0.5);\r\n            }\r\n            deletionMap[d.index] = {chars: d.chars, opacity};\r\n        });\r\n\r\n        // Process pasted characters for bold styling\r\n        if (this.pastedChars) {\r\n            this.pastedChars.forEach(p => {\r\n                if (p.index < text.length) {\r\n                    pastedMap[p.index] = true;\r\n                }\r\n            });\r\n        }\r\n\r\n        // Process AI characters for styling\r\n        if (this.aiChars) {\r\n            this.aiChars.forEach(p => {\r\n                if (p.index < text.length) {\r\n                    aiMap[p.index] = true;\r\n                }\r\n            });\r\n        }\r\n\r\n        // Find if we have out-of-bounds deletions (from Control+Backspace)\r\n        const outOfRangeDeletions = deletions.filter(d => d.index >= text.length);\r\n        const textLines = text.split('\\n');\r\n        let currentPosition = 0;\r\n\r\n        for (let lineIndex = 0; lineIndex < textLines.length; lineIndex++) {\r\n            const line = textLines[lineIndex];\r\n            for (let i = 0; i < line.length; i++) {\r\n                if (currentPosition === cursorPosition) {\r\n                    html += '<span class=\"tiny_cursive-cursor\"></span>';\r\n                }\r\n                const char = line[i];\r\n                if (deletionMap[currentPosition]) {\r\n                    html += `<span class=\"tiny_cursive-deleted-char\" style=\"opacity:\r\n                        ${deletionMap[currentPosition].opacity};\">${deletionMap[currentPosition].chars}</span>`;\r\n                }\r\n                const isPasted = pastedMap[currentPosition];\r\n                const isAi = aiMap[currentPosition];\r\n                const isHighlighted = highlightMap[currentPosition] && char !== ' ';\r\n\r\n                if (isPasted && isHighlighted) {\r\n                    html += `<span class=\"tiny_cursive-pasted-char tiny_cursive-highlighted-char\" style=\"opacity:\r\n                        ${highlightMap[currentPosition].opacity};\">${char}</span>`;\r\n                } else if (isAi && isHighlighted) {\r\n                    html += `<span class=\"tiny_cursive-ai-char tiny_cursive-highlighted-char\" style=\"opacity:\r\n                        ${highlightMap[currentPosition].opacity};\">${char}</span>`;\r\n                } else if (isPasted) {\r\n                    html += `<span class=\"tiny_cursive-pasted-char\">${char === ' ' ? ' ' : this.escapeHtml(char)}</span>`;\r\n                } else if (isAi) {\r\n                    html += `<span class=\"tiny_cursive-ai-char\">${char === ' ' ? ' ' : this.escapeHtml(char)}</span>`;\r\n                } else if (isHighlighted) {\r\n                    html += `<span class=\"tiny_cursive-highlighted-char\" style=\"opacity:\r\n                        ${highlightMap[currentPosition].opacity};\">${char}</span>`;\r\n                } else {\r\n                    html += char === ' ' ? ' ' : this.escapeHtml(char);\r\n                }\r\n                currentPosition++;\r\n            }\r\n            if (currentPosition === cursorPosition) {\r\n                html += '<span class=\"tiny_cursive-cursor\"></span>';\r\n            }\r\n            if (lineIndex < textLines.length - 1) {\r\n                html += '<br>';\r\n                currentPosition++;\r\n            }\r\n        }\r\n\r\n        if (cursorPosition === text.length && !html.endsWith('<span class=\"tiny_cursive-cursor\"></span>')) {\r\n            html += '<span class=\"tiny_cursive-cursor\"></span>';\r\n        }\r\n\r\n        if (outOfRangeDeletions.length > 0) {\r\n            outOfRangeDeletions.sort((a, b) => a.index - b.index);\r\n            const cursorHTML = '<span class=\"tiny_cursive-cursor\"></span>';\r\n            const cursorPos = html.lastIndexOf(cursorHTML);\r\n            if (cursorPos !== -1) {\r\n                let deletedWordHTML = '<span class=\"tiny_cursive-deleted-char\" style=\"opacity: 0.5;\">';\r\n                outOfRangeDeletions.forEach(d => {\r\n                    deletedWordHTML += d.chars;\r\n                });\r\n                deletedWordHTML += '</span>';\r\n                html = html.substring(0, cursorPos) + deletedWordHTML + html.substring(cursorPos);\r\n            }\r\n        }\r\n\r\n        const wasScrolledToBottom = this.outputElement.scrollHeight -\r\n            this.outputElement.clientHeight <= this.outputElement.scrollTop + 1;\r\n        this.outputElement.innerHTML = html;\r\n\r\n        if (wasScrolledToBottom || this.isCursorBelowViewport()) {\r\n            this.outputElement.scrollTop = this.outputElement.scrollHeight;\r\n        }\r\n    }\r\n\r\n    // Check if cursor is below visible viewport\r\n    isCursorBelowViewport() {\r\n        const cursorElement = this.outputElement.querySelector('.tiny_cursive-cursor:last-of-type');\r\n        if (!cursorElement) {\r\n            return false;\r\n        }\r\n\r\n        const cursorRect = cursorElement.getBoundingClientRect();\r\n        const outputRect = this.outputElement.getBoundingClientRect();\r\n\r\n        return cursorRect.bottom > outputRect.bottom;\r\n    }\r\n\r\n    escapeHtml(unsafe) {\r\n        return unsafe\r\n            .replace(/&/g, '&amp;')\r\n            .replace(/</g, '&lt;')\r\n            .replace(/>/g, '&gt;')\r\n            .replace(/\"/g, '&quot;')\r\n            .replace(/'/g, '&#039;');\r\n    }\r\n\r\n    // Used in various places to add a keydown, backspace, etc. to the output\r\n    applyKey(key) {\r\n        switch (key) {\r\n            case 'Enter':\r\n                return '\\n';\r\n            case 'Backspace':\r\n            case 'Delete':\r\n            case 'ControlBackspace':\r\n                return '';\r\n            case ' ':\r\n                 return ' ';\r\n            default:\r\n                return !['Shift', 'Ctrl', 'Alt', 'ArrowDown', 'ArrowUp', 'Control', 'ArrowRight',\r\n                    'ArrowLeft', 'Meta', 'CapsLock', 'Tab', 'Escape', 'Delete', 'PageUp', 'PageDown',\r\n                    'Insert', 'Home', 'End', 'NumLock', 'AudioVolumeUp', 'AudioVolumeDown',\r\n                    'MediaPlayPause', 'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10',\r\n                    'F11', 'F12', 'PrintScreen', 'UnIdentified'].includes(key) ? key : '';\r\n        }\r\n    }\r\n}\r\n"],"names":["constructor","elementId","filePath","speed","loop","controllerId","replayInProgress","parseFloat","highlightedChars","deletedChars","cursorPosition","currentEventIndex","totalEvents","currentTime","totalDuration","usercomments","pasteTimestamps","isPasteEvent","isControlKeyPressed","isShiftKeyPressed","isMetaKeyPressed","text","pastedEvents","currentPasteIndex","pastedChars","aiEvents","currentAiIndex","aiChars","undoTimestamps","undoChars","element","document","getElementById","Error","outputElement","loadJSON","then","data","status","processData","this","logData","length","identifyPasteEvents","identifyUndoEvents","constructController","startReplay","handleNoSubmission","catch","error","window","console","message","localStorage","getItem","Str","get_string","str","setItem","log","JSON","parse","comments","Array","isArray","payload","i","event","pastedContent","trim","push","aiContent","unixTimestamp","startTime","map","normalizedTime","html","Promise","all","templates","render","newElement","stopReplay","clearTimeout","replayTimeout","playButton","playSvg","createElement","src","M","util","image_url","querySelector","innerHTML","outerHTML","currentPosition","replayIntervalId","clearInterval","container","controlContainer","buildControllerUI","remove","topRow","classList","add","createPlayButton","appendChild","scrubberContainer","createScrubberContainer","timeDisplay","createTimeDisplay","bottomRow","speedContainer","createSpeedControls","pasteEventsToggle","createPasteEventsToggle","pasteEventsPanel","addEventListener","find","removeClass","addClass","scrubberElement","type","max","min","value","skipToTime","parseInt","textContent","speedLabel","speedGroup","forEach","speedBtn","dataset","querySelectorAll","btn","pasteEventsIcon","pasteIcon","pasteEventsText","pasteEventCount","className","style","marginLeft","chevronIcon","chevron","transition","createPasteEventsPanel","isHidden","display","transform","existingPanel","populatePasteEventsPanel","controlPressed","metaPressed","shiftPressed","pasteCount","toLowerCase","key","timestamp","index","time","formattedTime","formatTime","pastedText","undoCount","panel","noEventsMessage","carouselContainer","navigationRow","counterDisplay","navButtons","prevButton","nextButton","disabled","contentContainer","createPasteEventDisplay","currentIndex","updateDisplay","opacity","pasteEvent","eventRow","headerRow","textContainer","timestampContainer","pastedTextContainer","playIcon","jumpToTimestamp","percentage","setScrubberVal","String","displayTime","Math","methodname","args","filepath","done","response","fail","ms","seconds","floor","remainingSeconds","toString","padStart","reset","pauseSvg","replayLog","cursor","updatedHighlights","updatedDeleted","undefined","rePosition","processKeydownEvent","processAiInsertEvent","filter","h","expiresAt","d","updateDisplayText","percentComplete","baseIncrement","incrementTime","setTimeout","getLineAndColumn","pos","before","substring","lineIndex","split","col","lastIndexOf","highlights","deletions","targetPosition","handleAiReplacement","currentCursor","insertText","aiWords","isMultiWord","isNewLineInsertion","startsWith","endsWith","wordStart","wordEnd","findWordToReplace","wordToReplace","markCharsAsDeleted","replacedLength","positionDiff","newCursor","calculateNewCursorPosition","updateCharacterIndices","lineStart","lineEnd","findLineRange","lineText","words","extractWordsFromLine","findMultiWordMatch","findSingleWordMatch","start","end","bestMatch","score","wordCount","similarityScore","matchResult","evaluateMultiWordSequence","totalScore","closest","findClosestWord","startIndex","seqWords","j","calculateSequenceSimilarity","calculatePositionScore","compareLength","k","ai","seq","calculateSimilarity","positionScore","seqStart","seqEndPos","aiWord","aiWordLower","bestSimilarityMatch","findBestSimilarityMatch","word","bestPositionMatch","findBestPositionMatch","findWordBoundaryAtPosition","similarity","wordLower","calculateWordScore","distance","abs","chars","updatePastedCharIndices","markCharsAsAiInserted","updateAiCharIndices","p","justAddedIndices","Set","has","str1","str2","len1","len2","matrix","fill","cost","maxLen","minDistance","charToInsert","applyKey","isCopyOperation","isUndoOperation","handleUndoOperation","selection","detectSelection","isPasteOperation","handlePasteOperation","updateModifierStates","isSelectionDeletion","handleSelectionDeletion","processKeyOperation","nextEventIndex","nextEvent","newPosition","textBeforeUndo","handlePasteInsert","resetModifierStates","isCtrlBackspace","handleCtrlBackspace","isCtrlDelete","handleCtrlDelete","isCtrlArrowMove","handleCtrlArrowMove","isRegularBackspace","handleBackspace","isRegularDelete","handleDelete","isArrowUp","handleArrowUp","isArrowDown","handleArrowDown","isRegularArrowMove","handleArrowMove","handleCharacterInsert","eventIndex","currentEvent","currentPos","processDetection","nextPos","shiftPastedCharsIndices","numDeleted","includes","findPreviousWordBoundary","findNextWordBoundary","wordToDelete","lines","prevLine","slice","join","nextLine","lastNonSpace","skipToEnd","textOutput","wasPlaying","targetTime","pasteIndex","aiIndex","highlightMap","deletionMap","pastedMap","aiMap","outOfRangeDeletions","textLines","line","char","isPasted","isAi","isHighlighted","escapeHtml","sort","a","b","cursorHTML","cursorPos","deletedWordHTML","wasScrolledToBottom","scrollHeight","clientHeight","scrollTop","isCursorBelowViewport","cursorElement","cursorRect","getBoundingClientRect","outputRect","bottom","unsafe","replace"],"mappings":"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"}